# ç§‘æŠ€é¡µé¢è®¾è®¡æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### ğŸ¯ è®¾è®¡ç›®æ ‡

ä¸ºå¼‚æ˜Ÿå·¥å‚v2é¡¹ç›®è®¾è®¡å¹¶å®ç°åŠŸèƒ½å®Œæ•´çš„ç§‘æŠ€ç³»ç»Ÿï¼Œä½œä¸ºç¬¬ä¸€é˜¶æ®µå¼€å‘çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ã€‚ç§‘æŠ€ç³»ç»Ÿå°†æ§åˆ¶ç‰©å“å’Œé…æ–¹çš„è§£é”ï¼Œä¸ºç©å®¶æä¾›æ¸…æ™°çš„è¿›åº¦æ„Ÿå’Œç›®æ ‡å¯¼å‘ã€‚

### ğŸ”§ æŠ€æœ¯è¦æ±‚

- **æ¡†æ¶**: React + TypeScript + Material-UI
- **çŠ¶æ€ç®¡ç†**: å†…ç½®ReactçŠ¶æ€ + DataService
- **æ•°æ®æ¥æº**: Factorio 1.1.107å®˜æ–¹æ•°æ®
- **å…¼å®¹æ€§**: ç§»åŠ¨ç«¯å‹å¥½çš„å“åº”å¼è®¾è®¡

---

## ğŸ¨ UI/UX è®¾è®¡

### ğŸ“± æ•´ä½“å¸ƒå±€è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ§ª ç§‘æŠ€ç³»ç»Ÿ                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [ğŸ” æœç´¢] [ğŸ·ï¸ åˆ†ç±»ç­›é€‰] [ğŸ“Š è¿›åº¦æ¦‚è§ˆ]      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ ğŸŸ¢  â”‚â”€â”€â”‚ ğŸŸ¡  â”‚  â”‚ ğŸ”’  â”‚  â”‚ ğŸ”’  â”‚    â”‚
â”‚  â”‚åŸºç¡€ â”‚  â”‚ç”µå­ â”‚  â”‚é«˜çº§ â”‚  â”‚ç”Ÿäº§ â”‚    â”‚
â”‚  â”‚è‡ªåŠ¨ â”‚  â”‚å­¦   â”‚  â”‚ç”µè·¯ â”‚  â”‚æ¨¡å— â”‚    â”‚
â”‚  â”‚åŒ–   â”‚  â”‚     â”‚  â”‚     â”‚  â”‚     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ ğŸŸ¢  â”‚  â”‚ ğŸŸ¡  â”‚  â”‚ ğŸ”’  â”‚  â”‚ ğŸ”’  â”‚    â”‚
â”‚  â”‚ç‰©æµ â”‚  â”‚å¿«é€Ÿ â”‚  â”‚ç‰©æµ â”‚  â”‚æœºå™¨ â”‚    â”‚
â”‚  â”‚å­¦   â”‚  â”‚æœºæ¢° â”‚  â”‚æœºå™¨ â”‚  â”‚äºº   â”‚    â”‚
â”‚  â”‚     â”‚  â”‚è‡‚   â”‚  â”‚äºº   â”‚  â”‚     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ¯ ç ”ç©¶é˜Ÿåˆ—                              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ ğŸ”µ [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] ç”µå­å­¦    15s     â”‚ â”‚
â”‚ â”‚ ğŸŸ¡ [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] ç‰©æµæœºå™¨äºº  ç­‰å¾…ä¸­  â”‚ â”‚
â”‚ â”‚ ğŸŸ¡ [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] é«˜çº§ç”µè·¯    ç­‰å¾…ä¸­  â”‚ â”‚
â”‚ â”‚ â• æ·»åŠ åˆ°é˜Ÿåˆ— | ğŸ”„ é‡æ–°æ’åº | ğŸ—‘ï¸ æ¸…ç©º â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“‹ ç§‘æŠ€è¯¦æƒ…é¢æ¿                          â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ ğŸ”¬ ç”µå­å­¦                           â”‚ â”‚
â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚
â”‚ â”‚ ğŸ“– è§£é”ç”µå­ç”µè·¯å’Œç›¸å…³æŠ€æœ¯           â”‚ â”‚
â”‚ â”‚ ğŸ¯ å‰ç½®: åŸºç¡€è‡ªåŠ¨åŒ– âœ…               â”‚ â”‚
â”‚ â”‚ ğŸ’ æˆæœ¬: è‡ªåŠ¨åŒ–ç§‘æŠ€åŒ… x10           â”‚ â”‚
â”‚ â”‚ â±ï¸ æ—¶é—´: 15ç§’                       â”‚ â”‚
â”‚ â”‚ ğŸ”“ è§£é”: ç”µå­ç”µè·¯ã€é“œçº¿ã€å¿«é€Ÿæœºæ¢°è‡‚   â”‚ â”‚
â”‚ â”‚ [â• åŠ å…¥é˜Ÿåˆ—] [ğŸ”¬ ç«‹å³ç ”ç©¶] [ğŸ‘ï¸ é¢„è§ˆ] â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ¯ ç§‘æŠ€èŠ‚ç‚¹è®¾è®¡

#### **èŠ‚ç‚¹çŠ¶æ€ä¸è§†è§‰æ•ˆæœ**

```typescript
// ç§‘æŠ€èŠ‚ç‚¹çŠ¶æ€å®šä¹‰
type TechStatus =
  | 'unlocked' // ğŸŸ¢ å·²è§£é” - ç»¿è‰²è¾¹æ¡†ï¼Œæ­£å¸¸å›¾æ ‡
  | 'available' // ğŸŸ¡ å¯ç ”ç©¶ - é»„è‰²è¾¹æ¡†ï¼Œé«˜äº®å›¾æ ‡
  | 'researching' // ğŸ”µ ç ”ç©¶ä¸­ - è“è‰²è¾¹æ¡†ï¼Œè¿›åº¦ç¯
  | 'locked'; // ğŸ”’ é”å®š - ç°è‰²è¾¹æ¡†ï¼Œæš—åŒ–å›¾æ ‡
```

#### **èŠ‚ç‚¹ç»„ä»¶è®¾è®¡**

```jsx
// ç§‘æŠ€èŠ‚ç‚¹å¡ç‰‡
<TechNode>
  <TechIcon status="available" progress={0.3} />
  <TechName>ç”µå­å­¦</TechName>
  <TechBadge status="available">å¯ç ”ç©¶</TechBadge>
  <TechCost>
    <SciencePackIcon type="automation" count={10} />
  </TechCost>
</TechNode>
```

### ğŸ¯ ç ”ç©¶é˜Ÿåˆ—è®¾è®¡

#### **é˜Ÿåˆ—ç•Œé¢å¸ƒå±€**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ ç ”ç©¶é˜Ÿåˆ— (3/10)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ”µ [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] ç”µå­å­¦      15s âš¡ é«˜  â”‚
â”‚ ğŸŸ¡ [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] ç‰©æµæœºå™¨äºº   30s ğŸ“¦ ä¸­  â”‚
â”‚ ğŸŸ¡ [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] é«˜çº§ç”µè·¯     45s âš™ï¸ ä½  â”‚
â”‚ ğŸ”’ [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] ç”Ÿäº§æ¨¡å—    âš ï¸ ç¼ºå‰ç½®   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“Š é˜Ÿåˆ—ç»Ÿè®¡: æ€»æ—¶é—´ 90s | é¢„è®¡å®Œæˆ 15:30  â”‚
â”‚ [âš™ï¸ è‡ªåŠ¨ç ”ç©¶: âœ…] [ğŸ”„ é‡æ’] [ğŸ—‘ï¸ æ¸…ç©º]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **é˜Ÿåˆ—é¡¹ç›®çŠ¶æ€**

```typescript
// é˜Ÿåˆ—é¡¹ç›®çŠ¶æ€æšä¸¾
enum QueueItemStatus {
  RESEARCHING = 'researching', // ğŸ”µ æ­£åœ¨ç ”ç©¶
  READY = 'ready', // ğŸŸ¡ å‡†å¤‡å°±ç»ª
  BLOCKED = 'blocked', // ğŸ”’ å‰ç½®é˜»å¡
  INSUFFICIENT = 'insufficient', // âš ï¸ èµ„æºä¸è¶³
}

// ä¼˜å…ˆçº§æšä¸¾
enum ResearchPriority {
  HIGH = 0, // âš¡ é«˜ä¼˜å…ˆçº§ - çº¢è‰²
  NORMAL = 1, // ğŸ“¦ æ™®é€šä¼˜å…ˆçº§ - è“è‰²
  LOW = 2, // âš™ï¸ ä½ä¼˜å…ˆçº§ - ç°è‰²
}
```

#### **æ‹–æ‹½é‡æ’åŠŸèƒ½**

```jsx
// é˜Ÿåˆ—é¡¹ç›®æ”¯æŒæ‹–æ‹½é‡æ’
<QueueItem draggable onDragStart={handleDragStart} onDragOver={handleDragOver} onDrop={handleDrop}>
  <DragHandle>â‹®â‹®</DragHandle>
  <TechIcon />
  <TechInfo />
  <QueueActions />
</QueueItem>
```

### ğŸ”— ä¾èµ–å…³ç³»å¯è§†åŒ–

#### **è¿æ¥çº¿è®¾è®¡**

```css
.tech-connection {
  stroke: #e0e0e0; /* é»˜è®¤ç°è‰² */
  stroke-width: 2px;
  stroke-dasharray: none;
}

.tech-connection.highlighted {
  stroke: #2196f3; /* é«˜äº®è“è‰² */
  stroke-width: 3px;
  animation: flow 2s linear infinite;
}

.tech-connection.completed {
  stroke: #4caf50; /* å®Œæˆç»¿è‰² */
}
```

---

## ğŸ—‚ï¸ æ•°æ®ç»“æ„è®¾è®¡

### ğŸ“Š æ ¸å¿ƒæ•°æ®æ¨¡å‹

```typescript
// ç§‘æŠ€å®šä¹‰æ¥å£
interface Technology {
  id: string; // ç§‘æŠ€ID
  name: string; // æ˜¾ç¤ºåç§°
  description?: string; // ç§‘æŠ€æè¿°
  category: string; // ç§‘æŠ€åˆ†ç±»
  row: number; // ç§‘æŠ€æ ‘è¡Œä½ç½®

  // ä¾èµ–å…³ç³»
  prerequisites: string[]; // å‰ç½®ç§‘æŠ€IDæ•°ç»„
  dependencies?: string[]; // è½¯ä¾èµ–(å¯é€‰å‰ç½®)

  // ç ”ç©¶æˆæœ¬
  researchCost: {
    // ç§‘æŠ€åŒ…éœ€æ±‚
    [sciencePackId: string]: number;
  };
  researchTime: number; // åŸºç¡€ç ”ç©¶æ—¶é—´(ç§’)

  // è§£é”å†…å®¹
  unlocks: {
    items?: string[]; // è§£é”çš„ç‰©å“
    recipes?: string[]; // è§£é”çš„é…æ–¹
    buildings?: string[]; // è§£é”çš„å»ºç­‘
    features?: string[]; // è§£é”çš„åŠŸèƒ½
  };

  // æ˜¾ç¤ºå±æ€§
  icon?: string; // ç§‘æŠ€å›¾æ ‡
  position: {
    // UIä¸­çš„ä½ç½®
    x: number;
    y: number;
  };
}

// ç§‘æŠ€ç ”ç©¶çŠ¶æ€
interface TechResearchState {
  techId: string;
  status: TechStatus;
  progress: number; // ç ”ç©¶è¿›åº¦ 0-1
  timeStarted?: number; // å¼€å§‹æ—¶é—´æˆ³
  timeRemaining?: number; // å‰©ä½™æ—¶é—´(ç§’)
  currentCost: {
    // å½“å‰æŠ•å…¥çš„ç§‘æŠ€åŒ…
    [sciencePackId: string]: number;
  };
}

// ç ”ç©¶é˜Ÿåˆ—é¡¹ç›®
interface ResearchQueueItem {
  techId: string;
  addedTime: number; // æ·»åŠ åˆ°é˜Ÿåˆ—çš„æ—¶é—´
  priority: number; // ä¼˜å…ˆçº§ (0-é«˜, 1-ä¸­, 2-ä½)
  estimatedStartTime?: number; // é¢„è®¡å¼€å§‹æ—¶é—´
  canStart: boolean; // æ˜¯å¦å¯ä»¥å¼€å§‹ç ”ç©¶
  blockedBy?: string[]; // è¢«å“ªäº›å‰ç½®ç§‘æŠ€é˜»å¡
}

// ç§‘æŠ€æ ‘çŠ¶æ€ç®¡ç†
interface TechTreeState {
  unlockedTechs: Set<string>; // å·²è§£é”ç§‘æŠ€é›†åˆ
  researchedTechs: Set<string>; // å·²ç ”ç©¶å®Œæˆç§‘æŠ€é›†åˆ
  currentResearch?: TechResearchState; // å½“å‰ç ”ç©¶
  researchQueue: ResearchQueueItem[]; // ç ”ç©¶é˜Ÿåˆ— (æœ‰åº)

  // é˜Ÿåˆ—ç®¡ç†
  maxQueueSize: number; // æœ€å¤§é˜Ÿåˆ—é•¿åº¦
  autoResearch: boolean; // æ˜¯å¦è‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªç ”ç©¶
  queueTotalTime: number; // é˜Ÿåˆ—æ€»é¢„è®¡æ—¶é—´

  // ç¼“å­˜è®¡ç®—ç»“æœ
  availableTechs: Set<string>; // å¯ç ”ç©¶ç§‘æŠ€ç¼“å­˜
  unlockedItems: Set<string>; // å¯ç”¨ç‰©å“ç¼“å­˜
  unlockedRecipes: Set<string>; // å¯ç”¨é…æ–¹ç¼“å­˜
}
```

### ğŸ¯ ç§‘æŠ€åˆ†ç±»ç³»ç»Ÿ

```typescript
// ç§‘æŠ€åˆ†ç±»å®šä¹‰
interface TechCategory {
  id: string;
  name: string;
  icon: string;
  color: string;
  description: string;
}

// é¢„å®šä¹‰ç§‘æŠ€åˆ†ç±»
export const TECH_CATEGORIES: TechCategory[] = [
  {
    id: 'automation',
    name: 'è‡ªåŠ¨åŒ–',
    icon: 'âš™ï¸',
    color: '#4CAF50',
    description: 'åŸºç¡€è‡ªåŠ¨åŒ–å’Œç”Ÿäº§æŠ€æœ¯',
  },
  {
    id: 'logistics',
    name: 'ç‰©æµ',
    icon: 'ğŸ“¦',
    color: '#2196F3',
    description: 'ç‰©å“ä¼ è¾“å’Œå­˜å‚¨æŠ€æœ¯',
  },
  {
    id: 'military',
    name: 'å†›äº‹',
    icon: 'âš”ï¸',
    color: '#F44336',
    description: 'æ­¦å™¨é˜²å¾¡å’Œæˆ˜æ–—æŠ€æœ¯',
  },
  {
    id: 'production',
    name: 'ç”Ÿäº§',
    icon: 'ğŸ­',
    color: '#FF9800',
    description: 'é«˜çº§ç”Ÿäº§å’Œåˆ¶é€ æŠ€æœ¯',
  },
  {
    id: 'utility',
    name: 'å®ç”¨',
    icon: 'ğŸ”§',
    color: '#9C27B0',
    description: 'å·¥å…·å’Œè¾…åŠ©æŠ€æœ¯',
  },
];
```

---

## âš™ï¸ æŠ€æœ¯å®ç°

### ğŸ—ï¸ ç»„ä»¶æ¶æ„

```typescript
// ä¸»ç§‘æŠ€é¡µé¢ç»„ä»¶
interface TechPageProps {
  onTechSelect?: (techId: string) => void;
  onItemUnlock?: (itemIds: string[]) => void;
}

// ç»„ä»¶å±‚æ¬¡ç»“æ„
<TechPage>
  <TechPageHeader>
    <TechSearch />
    <TechCategoryFilter />
    <TechProgressOverview />
  </TechPageHeader>

  <TechTreeView>
    <TechGrid>
      {technologies.map(tech =>
        <TechNode
          key={tech.id}
          technology={tech}
          state={techStates[tech.id]}
          onSelect={handleTechSelect}
          onAddToQueue={handleAddToQueue}
          onStartResearch={handleStartResearch}
        />
      )}
    </TechGrid>
    <TechConnections />
  </TechTreeView>

  <ResearchQueue>
    <QueueHeader>
      <QueueProgress />
      <QueueControls />
    </QueueHeader>
    <QueueList>
      {queueItems.map(item =>
        <QueueItem
          key={item.techId}
          queueItem={item}
          onRemove={handleRemoveFromQueue}
          onReorder={handleReorderQueue}
          onPriorityChange={handlePriorityChange}
        />
      )}
    </QueueList>
  </ResearchQueue>

  <TechDetailPanel>
    <TechInfo />
    <UnlockPreview />
    <ResearchControls />
  </TechDetailPanel>
</TechPage>
```

### ğŸ“¡ æœåŠ¡å±‚è®¾è®¡

```typescript
// ç§‘æŠ€æœåŠ¡æ ¸å¿ƒæ¥å£
class TechnologyService {
  private techTree: Map<string, Technology> = new Map();
  private techState: TechTreeState;

  // åˆå§‹åŒ–æ–¹æ³•
  async initialize(gameData: GameData): Promise<void> {
    this.loadTechnologies(gameData);
    this.loadInitialUnlocks();
    this.calculateAvailableTechs();
  }

  // çŠ¶æ€æŸ¥è¯¢æ–¹æ³•
  isTechUnlocked(techId: string): boolean {
    return this.techState.unlockedTechs.has(techId);
  }

  isTechAvailable(techId: string): boolean {
    return this.techState.availableTechs.has(techId);
  }

  isItemUnlocked(itemId: string): boolean {
    return this.techState.unlockedItems.has(itemId);
  }

  // ç ”ç©¶é˜Ÿåˆ—ç®¡ç†æ–¹æ³•
  addToResearchQueue(techId: string, priority: number = 1): QueueResult {
    // æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦å·²æ»¡
    if (this.techState.researchQueue.length >= this.techState.maxQueueSize) {
      return { success: false, error: 'Research queue is full' };
    }

    // æ£€æŸ¥æ˜¯å¦å·²åœ¨é˜Ÿåˆ—ä¸­
    if (this.techState.researchQueue.some((item) => item.techId === techId)) {
      return { success: false, error: 'Technology already in queue' };
    }

    // æ£€æŸ¥æ˜¯å¦å·²è§£é”
    if (this.techState.unlockedTechs.has(techId)) {
      return { success: false, error: 'Technology already unlocked' };
    }

    // æ·»åŠ åˆ°é˜Ÿåˆ—
    const queueItem: ResearchQueueItem = {
      techId,
      addedTime: Date.now(),
      priority,
      canStart: this.isTechAvailable(techId),
      blockedBy: this.getBlockingTechs(techId),
    };

    // æŒ‰ä¼˜å…ˆçº§æ’å…¥é˜Ÿåˆ—
    this.insertQueueItemByPriority(queueItem);

    // é‡æ–°è®¡ç®—é˜Ÿåˆ—æ—¶é—´
    this.recalculateQueueTimes();

    return { success: true, queuePosition: this.getQueuePosition(techId) };
  }

  removeFromResearchQueue(techId: string): boolean {
    const index = this.techState.researchQueue.findIndex((item) => item.techId === techId);
    if (index === -1) return false;

    this.techState.researchQueue.splice(index, 1);
    this.recalculateQueueTimes();
    return true;
  }

  reorderResearchQueue(techId: string, newPosition: number): boolean {
    const oldIndex = this.techState.researchQueue.findIndex((item) => item.techId === techId);
    if (oldIndex === -1) return false;

    const item = this.techState.researchQueue.splice(oldIndex, 1)[0];
    this.techState.researchQueue.splice(newPosition, 0, item);
    this.recalculateQueueTimes();
    return true;
  }

  // ç ”ç©¶ç®¡ç†æ–¹æ³•
  startResearch(techId: string): ResearchResult {
    // éªŒè¯å‰ç½®æ¡ä»¶
    if (!this.isTechAvailable(techId)) {
      return { success: false, error: 'Prerequisites not met' };
    }

    // æ£€æŸ¥èµ„æº
    const tech = this.techTree.get(techId);
    if (!this.hasRequiredSciencePacks(tech.researchCost)) {
      return { success: false, error: 'Insufficient science packs' };
    }

    // å¼€å§‹ç ”ç©¶
    this.techState.currentResearch = {
      techId,
      status: 'researching',
      progress: 0,
      timeStarted: Date.now(),
      timeRemaining: tech.researchTime,
      currentCost: { ...tech.researchCost },
    };

    // ä»é˜Ÿåˆ—ä¸­ç§»é™¤(å¦‚æœå­˜åœ¨)
    this.removeFromResearchQueue(techId);

    return { success: true };
  }

  // è‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªç ”ç©¶
  startNextResearch(): boolean {
    if (!this.techState.autoResearch) return false;
    if (this.techState.currentResearch) return false;
    if (this.techState.researchQueue.length === 0) return false;

    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯ä»¥å¼€å§‹çš„ç ”ç©¶
    const availableItem = this.techState.researchQueue.find((item) => item.canStart);
    if (!availableItem) return false;

    const result = this.startResearch(availableItem.techId);
    return result.success;
  }

  completeResearch(techId: string): void {
    // è§£é”ç§‘æŠ€
    this.techState.unlockedTechs.add(techId);
    this.techState.researchedTechs.add(techId);

    // è§£é”å†…å®¹
    const tech = this.techTree.get(techId);
    tech.unlocks.items?.forEach((itemId) => this.techState.unlockedItems.add(itemId));
    tech.unlocks.recipes?.forEach((recipeId) => this.techState.unlockedRecipes.add(recipeId));

    // é‡æ–°è®¡ç®—å¯ç”¨ç§‘æŠ€
    this.calculateAvailableTechs();

    // æ¸…é™¤å½“å‰ç ”ç©¶
    this.techState.currentResearch = undefined;

    // æ›´æ–°é˜Ÿåˆ—ä¸­çš„ä¾èµ–çŠ¶æ€
    this.updateQueueDependencies();

    // è‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªç ”ç©¶
    if (this.techState.autoResearch) {
      setTimeout(() => this.startNextResearch(), 100);
    }

    // è§¦å‘è§£é”äº‹ä»¶
    this.eventEmitter.emit('techUnlocked', { techId, tech });
  }

  // ä¾èµ–å…³ç³»è®¡ç®—
  private calculateAvailableTechs(): void {
    this.techState.availableTechs.clear();

    for (const [techId, tech] of this.techTree) {
      // è·³è¿‡å·²è§£é”çš„ç§‘æŠ€
      if (this.techState.unlockedTechs.has(techId)) continue;

      // æ£€æŸ¥æ‰€æœ‰å‰ç½®ç§‘æŠ€æ˜¯å¦å·²è§£é”
      const prerequisitesMet = tech.prerequisites.every((prereqId) => this.techState.unlockedTechs.has(prereqId));

      if (prerequisitesMet) {
        this.techState.availableTechs.add(techId);
      }
    }
  }

  // è·å–ç§‘æŠ€ä¾èµ–é“¾
  getTechDependencyChain(techId: string): string[] {
    const visited = new Set<string>();
    const chain: string[] = [];

    const dfs = (currentTechId: string) => {
      if (visited.has(currentTechId)) return;
      visited.add(currentTechId);

      const tech = this.techTree.get(currentTechId);
      if (!tech) return;

      // å…ˆå¤„ç†å‰ç½®ç§‘æŠ€
      tech.prerequisites.forEach((prereqId) => dfs(prereqId));

      // å†æ·»åŠ å½“å‰ç§‘æŠ€
      chain.push(currentTechId);
    };

    dfs(techId);
    return chain;
  }
}
```

### ğŸ® äº¤äº’é€»è¾‘

```typescript
// ç§‘æŠ€é¡µé¢ä¸»ç»„ä»¶
const TechPage: React.FC<TechPageProps> = ({ onTechSelect, onItemUnlock }) => {
  const [selectedTech, setSelectedTech] = useState<string | null>(null);
  const [filterCategory, setFilterCategory] = useState<string>('all');
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [techStates, setTechStates] = useState<Map<string, TechResearchState>>(new Map());
  const [researchQueue, setResearchQueue] = useState<ResearchQueueItem[]>([]);
  const [autoResearch, setAutoResearch] = useState<boolean>(true);

  // ç§‘æŠ€é€‰æ‹©å¤„ç†
  const handleTechSelect = useCallback((techId: string) => {
    setSelectedTech(techId);
    onTechSelect?.(techId);

    // é«˜äº®ä¾èµ–é“¾
    const dependencyChain = technologyService.getTechDependencyChain(techId);
    setHighlightedTechs(new Set(dependencyChain));
  }, [onTechSelect]);

  // æ·»åŠ åˆ°ç ”ç©¶é˜Ÿåˆ—
  const handleAddToQueue = useCallback(async (techId: string, priority: number = 1) => {
    try {
      const result = await technologyService.addToResearchQueue(techId, priority);

      if (result.success) {
        // æ›´æ–°é˜Ÿåˆ—çŠ¶æ€
        const updatedQueue = technologyService.getResearchQueue();
        setResearchQueue(updatedQueue);

        showSuccessMessage(`å·²æ·»åŠ åˆ°ç ”ç©¶é˜Ÿåˆ—: ${technologyService.getTechnology(techId)?.name}`);
      } else {
        showErrorMessage(result.error);
      }
    } catch (error) {
      console.error('Add to queue failed:', error);
      showErrorMessage('æ·»åŠ åˆ°é˜Ÿåˆ—å¤±è´¥');
    }
  }, []);

  // ä»é˜Ÿåˆ—ç§»é™¤
  const handleRemoveFromQueue = useCallback((techId: string) => {
    const success = technologyService.removeFromResearchQueue(techId);
    if (success) {
      const updatedQueue = technologyService.getResearchQueue();
      setResearchQueue(updatedQueue);
      showSuccessMessage('å·²ä»é˜Ÿåˆ—ç§»é™¤');
    }
  }, []);

  // é˜Ÿåˆ—é‡æ–°æ’åº
  const handleReorderQueue = useCallback((techId: string, newPosition: number) => {
    const success = technologyService.reorderResearchQueue(techId, newPosition);
    if (success) {
      const updatedQueue = technologyService.getResearchQueue();
      setResearchQueue(updatedQueue);
    }
  }, []);

  // å¼€å§‹ç ”ç©¶å¤„ç†
  const handleStartResearch = useCallback(async (techId: string) => {
    try {
      const result = await technologyService.startResearch(techId);

      if (result.success) {
        // æ›´æ–°UIçŠ¶æ€
        setTechStates(prev => new Map(prev).set(techId, {
          techId,
          status: 'researching',
          progress: 0,
          timeStarted: Date.now(),
          currentCost: { ...result.cost }
        }));

        // å¼€å§‹ç ”ç©¶å€’è®¡æ—¶
        startResearchTimer(techId);

        // æ›´æ–°é˜Ÿåˆ—çŠ¶æ€(ç§»é™¤å·²å¼€å§‹çš„ç ”ç©¶)
        const updatedQueue = technologyService.getResearchQueue();
        setResearchQueue(updatedQueue);

        showSuccessMessage(`å¼€å§‹ç ”ç©¶: ${result.techName}`);
      } else {
        showErrorMessage(result.error);
      }
    } catch (error) {
      console.error('Research failed:', error);
      showErrorMessage('ç ”ç©¶å¯åŠ¨å¤±è´¥');
    }
  }, []);

  // ç ”ç©¶å€’è®¡æ—¶
  const startResearchTimer = useCallback((techId: string) => {
    const interval = setInterval(() => {
      setTechStates(prev => {
        const newStates = new Map(prev);
        const techState = newStates.get(techId);

        if (!techState || techState.status !== 'researching') {
          clearInterval(interval);
          return prev;
        }

        const elapsed = (Date.now() - techState.timeStarted!) / 1000;
        const progress = Math.min(elapsed / techState.timeRemaining!, 1);

        if (progress >= 1) {
          // ç ”ç©¶å®Œæˆ
          clearInterval(interval);
          handleResearchComplete(techId);
          return prev;
        }

        // æ›´æ–°è¿›åº¦
        newStates.set(techId, {
          ...techState,
          progress,
          timeRemaining: Math.max(0, techState.timeRemaining! - 1)
        });

        return newStates;
      });
    }, 1000);
  }, []);

  // ç ”ç©¶å®Œæˆå¤„ç†
  const handleResearchComplete = useCallback((techId: string) => {
    try {
      technologyService.completeResearch(techId);

      // æ›´æ–°çŠ¶æ€
      setTechStates(prev => {
        const newStates = new Map(prev);
        newStates.set(techId, {
          techId,
          status: 'unlocked',
          progress: 1,
          currentCost: {}
        });
        return newStates;
      });

      // è·å–è§£é”å†…å®¹
      const tech = technologyService.getTechnology(techId);
      const unlockedItems = [
        ...(tech.unlocks.items || []),
        ...(tech.unlocks.recipes || []),
        ...(tech.unlocks.buildings || [])
      ];

      // è§¦å‘è§£é”å›è°ƒ
      onItemUnlock?.(unlockedItems);

      // æ›´æ–°é˜Ÿåˆ—çŠ¶æ€
      const updatedQueue = technologyService.getResearchQueue();
      setResearchQueue(updatedQueue);

      // æ˜¾ç¤ºè§£é”é€šçŸ¥
      showUnlockNotification(tech, unlockedItems);

    } catch (error) {
      console.error('Research completion failed:', error);
    }
  }, [onItemUnlock]);

  return (
    <Box sx={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* é¡µé¢å¤´éƒ¨ */}
      <TechPageHeader
        searchQuery={searchQuery}
        onSearchChange={setSearchQuery}
        filterCategory={filterCategory}
        onFilterChange={setFilterCategory}
      />

      {/* ç§‘æŠ€æ ‘ä¸»ä½“ */}
      <TechTreeView
        technologies={filteredTechnologies}
        techStates={techStates}
        selectedTech={selectedTech}
        highlightedTechs={highlightedTechs}
        onTechSelect={handleTechSelect}
        onAddToQueue={handleAddToQueue}
        onStartResearch={handleStartResearch}
      />

      {/* ç ”ç©¶é˜Ÿåˆ— */}
      <ResearchQueue
        queueItems={researchQueue}
        currentResearch={techStates.get('current')}
        autoResearch={autoResearch}
        onRemoveFromQueue={handleRemoveFromQueue}
        onReorderQueue={handleReorderQueue}
        onToggleAutoResearch={setAutoResearch}
        onClearQueue={() => {
          technologyService.clearResearchQueue();
          setResearchQueue([]);
        }}
      />

      {/* è¯¦æƒ…é¢æ¿ */}
      {selectedTech && (
        <TechDetailPanel
          techId={selectedTech}
          techState={techStates.get(selectedTech)}
          onAddToQueue={handleAddToQueue}
          onStartResearch={handleStartResearch}
          onClose={() => setSelectedTech(null)}
        />
      )}
    </Box>
  );
};
```

---

## ğŸ¯ é¢„è®¾ç§‘æŠ€æ•°æ®

### ğŸ“‹ ç¬¬ä¸€é˜¶æ®µåŸºç¡€ç§‘æŠ€

```typescript
// ç¬¬ä¸€é˜¶æ®µé¢„è®¾è§£é”ç§‘æŠ€
export const INITIAL_UNLOCKED_TECHS = [
  'manual-crafting', // æ‰‹å·¥åˆ¶ä½œ
  'basic-automation', // åŸºç¡€è‡ªåŠ¨åŒ–
  'logistics', // åŸºç¡€ç‰©æµ
  'tool-belt', // å·¥å…·å¸¦
];

// åŸºç¡€ç§‘æŠ€å®šä¹‰
export const BASE_TECHNOLOGIES: Technology[] = [
  {
    id: 'manual-crafting',
    name: 'æ‰‹å·¥åˆ¶ä½œ',
    description: 'ä½¿ç”¨åŒæ‰‹åˆ¶ä½œåŸºç¡€ç‰©å“',
    category: 'automation',
    row: 0,
    prerequisites: [],
    researchCost: {},
    researchTime: 0,
    unlocks: {
      items: ['wooden-chest', 'iron-plate', 'copper-plate'],
      recipes: ['iron-plate', 'copper-plate', 'stone-brick'],
    },
    position: { x: 0, y: 0 },
  },

  {
    id: 'basic-automation',
    name: 'åŸºç¡€è‡ªåŠ¨åŒ–',
    description: 'è§£é”åŸºç¡€ç”Ÿäº§è®¾æ–½',
    category: 'automation',
    row: 1,
    prerequisites: ['manual-crafting'],
    researchCost: {
      'automation-science-pack': 10,
    },
    researchTime: 10,
    unlocks: {
      buildings: ['stone-furnace', 'burner-mining-drill'],
      recipes: ['automation-science-pack', 'copper-cable'],
    },
    position: { x: 1, y: 0 },
  },

  {
    id: 'electronics',
    name: 'ç”µå­å­¦',
    description: 'è§£é”ç”µå­ç”µè·¯å’Œç›¸å…³æŠ€æœ¯',
    category: 'automation',
    row: 2,
    prerequisites: ['basic-automation'],
    researchCost: {
      'automation-science-pack': 30,
    },
    researchTime: 15,
    unlocks: {
      items: ['electronic-circuit', 'copper-cable'],
      recipes: ['electronic-circuit', 'copper-cable'],
      buildings: ['assembling-machine-1'],
    },
    position: { x: 2, y: 0 },
  },

  {
    id: 'logistics',
    name: 'ç‰©æµå­¦',
    description: 'è§£é”åŸºç¡€ç‰©æµè®¾å¤‡',
    category: 'logistics',
    row: 1,
    prerequisites: ['manual-crafting'],
    researchCost: {
      'automation-science-pack': 15,
    },
    researchTime: 15,
    unlocks: {
      buildings: ['transport-belt', 'inserter', 'iron-chest'],
      items: ['transport-belt', 'inserter', 'iron-chest'],
    },
    position: { x: 1, y: 1 },
  },

  {
    id: 'fast-inserter',
    name: 'å¿«é€Ÿæœºæ¢°è‡‚',
    description: 'æ›´å¿«çš„ç‰©å“ä¼ è¾“é€Ÿåº¦',
    category: 'logistics',
    row: 2,
    prerequisites: ['electronics', 'logistics'],
    researchCost: {
      'automation-science-pack': 40,
    },
    researchTime: 20,
    unlocks: {
      buildings: ['fast-inserter'],
      items: ['fast-inserter'],
    },
    position: { x: 2, y: 1 },
  },
];
```

---

## ğŸš€ å®æ–½è®¡åˆ’

### ğŸ“… å¼€å‘é‡Œç¨‹ç¢‘

#### **Phase 1: åŸºç¡€æ¶æ„ (2å¤©)**

- [ ] TechnologyService æ ¸å¿ƒæœåŠ¡å®ç°
- [ ] åŸºç¡€æ•°æ®ç»“æ„å’Œç±»å‹å®šä¹‰
- [ ] ç§‘æŠ€çŠ¶æ€ç®¡ç†ç³»ç»Ÿ
- [ ] é¢„è®¾ç§‘æŠ€æ•°æ®åŠ è½½

#### **Phase 2: UIç»„ä»¶ (2å¤©)**

- [ ] TechNode ç§‘æŠ€èŠ‚ç‚¹ç»„ä»¶
- [ ] TechGrid ç§‘æŠ€ç½‘æ ¼å¸ƒå±€
- [ ] TechDetailPanel è¯¦æƒ…é¢æ¿
- [ ] åŸºç¡€äº¤äº’å’ŒçŠ¶æ€ç»‘å®š

#### **Phase 3: æ ¸å¿ƒåŠŸèƒ½ (2å¤©)**

- [ ] ç§‘æŠ€è§£é”é€»è¾‘å®ç°
- [ ] ç ”ç©¶è¿›åº¦ç®¡ç†
- [ ] ç ”ç©¶é˜Ÿåˆ—æ ¸å¿ƒåŠŸèƒ½
- [ ] ç‰©å“è¿‡æ»¤é›†æˆ
- [ ] ä¾èµ–å…³ç³»è®¡ç®—

#### **Phase 4: é«˜çº§åŠŸèƒ½ (1å¤©)**

- [ ] æœç´¢å’Œç­›é€‰åŠŸèƒ½
- [ ] ç ”ç©¶é˜Ÿåˆ—UIå’Œäº¤äº’
- [ ] æ‹–æ‹½é‡æ’åŠŸèƒ½
- [ ] è§£é”é€šçŸ¥ç³»ç»Ÿ
- [ ] æ•°æ®æŒä¹…åŒ–

#### **Phase 5: ä¼˜åŒ–å’Œæµ‹è¯• (1å¤©)**

- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] ç§»åŠ¨ç«¯é€‚é…
- [ ] ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- [ ] é›†æˆæµ‹è¯•

### ğŸ¯ æˆåŠŸéªŒæ”¶æ ‡å‡†

#### **åŠŸèƒ½å®Œæ•´æ€§**

- âœ… ç§‘æŠ€çŠ¶æ€æ­£ç¡®æ˜¾ç¤ºï¼ˆå·²è§£é”/å¯ç ”ç©¶/é”å®šï¼‰
- âœ… ç ”ç©¶åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- âœ… ç‰©å“è§£é”è¿‡æ»¤ç”Ÿæ•ˆ
- âœ… ä¾èµ–å…³ç³»æ­£ç¡®è®¡ç®—

#### **ç”¨æˆ·ä½“éªŒ**

- âœ… ç•Œé¢å“åº”æµç•…ï¼ˆ<100msï¼‰
- âœ… ç§»åŠ¨ç«¯æ“ä½œå‹å¥½
- âœ… è§†è§‰åé¦ˆæ¸…æ™°
- âœ… é”™è¯¯å¤„ç†å®Œå–„

#### **æŠ€æœ¯è´¨é‡**

- âœ… ä»£ç ç»“æ„æ¸…æ™°
- âœ… TypeScriptç±»å‹å®‰å…¨
- âœ… ç»„ä»¶å¯å¤ç”¨æ€§é«˜
- âœ… æ€§èƒ½è¡¨ç°è‰¯å¥½

---

## ğŸ“š APIå‚è€ƒ

### ğŸ”§ TechnologyService API

```typescript
interface ITechnologyService {
  // åˆå§‹åŒ–
  initialize(gameData: GameData): Promise<void>;

  // çŠ¶æ€æŸ¥è¯¢
  isTechUnlocked(techId: string): boolean;
  isTechAvailable(techId: string): boolean;
  isItemUnlocked(itemId: string): boolean;
  getTechStatus(techId: string): TechStatus;

  // æ•°æ®è·å–
  getTechnology(techId: string): Technology | undefined;
  getAllTechnologies(): Technology[];
  getTechnologiesByCategory(category: string): Technology[];
  getUnlockedItems(): string[];
  getUnlockedRecipes(): string[];

  // ç ”ç©¶ç®¡ç†
  startResearch(techId: string): ResearchResult;
  cancelResearch(): void;
  completeResearch(techId: string): void;
  getCurrentResearch(): TechResearchState | undefined;

  // ç ”ç©¶é˜Ÿåˆ—ç®¡ç†
  addToResearchQueue(techId: string, priority?: number): QueueResult;
  removeFromResearchQueue(techId: string): boolean;
  reorderResearchQueue(techId: string, newPosition: number): boolean;
  getResearchQueue(): ResearchQueueItem[];
  clearResearchQueue(): void;
  getQueueTotalTime(): number;
  setAutoResearch(enabled: boolean): void;

  // ä¾èµ–å…³ç³»
  getTechPrerequisites(techId: string): string[];
  getTechDependents(techId: string): string[];
  getTechDependencyChain(techId: string): string[];

  // äº‹ä»¶ç›‘å¬
  on(event: 'techUnlocked', callback: (data: TechUnlockEvent) => void): void;
  on(event: 'researchStarted', callback: (data: ResearchStartEvent) => void): void;
  on(event: 'researchCompleted', callback: (data: ResearchCompleteEvent) => void): void;
}
```

### ğŸ¨ ç»„ä»¶ Props æ¥å£

```typescript
// ç§‘æŠ€èŠ‚ç‚¹ç»„ä»¶
interface TechNodeProps {
  technology: Technology;
  state: TechResearchState;
  highlighted?: boolean;
  onClick?: (techId: string) => void;
  onAddToQueue?: (techId: string, priority?: number) => void;
  onStartResearch?: (techId: string) => void;
}

// ç§‘æŠ€è¯¦æƒ…é¢æ¿
interface TechDetailPanelProps {
  techId: string;
  techState?: TechResearchState;
  onAddToQueue?: (techId: string, priority?: number) => void;
  onStartResearch?: (techId: string) => void;
  onClose?: () => void;
}

// ç ”ç©¶é˜Ÿåˆ—ç»„ä»¶
interface ResearchQueueProps {
  queueItems: ResearchQueueItem[];
  currentResearch?: TechResearchState;
  autoResearch: boolean;
  onRemoveFromQueue?: (techId: string) => void;
  onReorderQueue?: (techId: string, newPosition: number) => void;
  onToggleAutoResearch?: (enabled: boolean) => void;
  onClearQueue?: () => void;
}

// é˜Ÿåˆ—é¡¹ç›®ç»„ä»¶
interface QueueItemProps {
  queueItem: ResearchQueueItem;
  technology: Technology;
  position: number;
  isNext: boolean;
  onRemove?: (techId: string) => void;
  onMoveUp?: (techId: string) => void;
  onMoveDown?: (techId: string) => void;
  onPriorityChange?: (techId: string, priority: number) => void;
}

// ç§‘æŠ€ç½‘æ ¼
interface TechGridProps {
  technologies: Technology[];
  techStates: Map<string, TechResearchState>;
  selectedTech?: string;
  highlightedTechs?: Set<string>;
  onTechSelect?: (techId: string) => void;
  onStartResearch?: (techId: string) => void;
}
```

---

## ğŸ‰ æ€»ç»“

æœ¬è®¾è®¡æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ç§‘æŠ€é¡µé¢å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

- **ğŸ¨ ç›´è§‚çš„UI/UXè®¾è®¡** - æ¸…æ™°çš„è§†è§‰å±‚æ¬¡å’Œäº¤äº’æµç¨‹
- **ğŸ—ï¸ å¥å£®çš„æŠ€æœ¯æ¶æ„** - æ¨¡å—åŒ–ç»„ä»¶å’ŒæœåŠ¡è®¾è®¡
- **âš¡ é«˜æ•ˆçš„æ€§èƒ½ä¼˜åŒ–** - æ™ºèƒ½ç¼“å­˜å’ŒçŠ¶æ€ç®¡ç†
- **ğŸ“± å®Œå–„çš„ç§»åŠ¨ç«¯æ”¯æŒ** - å“åº”å¼å¸ƒå±€å’Œè§¦æ§ä¼˜åŒ–
- **ğŸ”§ çµæ´»çš„æ‰©å±•èƒ½åŠ›** - ä¸ºæœªæ¥åŠŸèƒ½é¢„ç•™æ¥å£

## ğŸ¯ ç ”ç©¶é˜Ÿåˆ—æ ¸å¿ƒç‰¹æ€§

### **ğŸ“‹ é˜Ÿåˆ—ç®¡ç†åŠŸèƒ½**

- **æ™ºèƒ½æ’åº** - è‡ªåŠ¨æŒ‰ä¼˜å…ˆçº§å’Œä¾èµ–å…³ç³»æ’åº
- **æ‹–æ‹½é‡æ’** - æ”¯æŒæ‰‹åŠ¨è°ƒæ•´ç ”ç©¶é¡ºåº
- **ä¾èµ–æ£€æŸ¥** - è‡ªåŠ¨æ£€æµ‹å’Œæ˜¾ç¤ºå‰ç½®ç§‘æŠ€é˜»å¡
- **èµ„æºé¢„æ£€** - æå‰æ£€æŸ¥ç§‘æŠ€åŒ…åº“å­˜æ˜¯å¦å……è¶³

### **âš¡ è‡ªåŠ¨ç ”ç©¶ç³»ç»Ÿ**

- **æ— ç¼è¡”æ¥** - å½“å‰ç ”ç©¶å®Œæˆåè‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ª
- **æ™ºèƒ½è·³è¿‡** - è‡ªåŠ¨è·³è¿‡è¢«é˜»å¡çš„ç ”ç©¶é¡¹ç›®
- **ä¼˜å…ˆçº§æ”¯æŒ** - é«˜ä¼˜å…ˆçº§é¡¹ç›®ä¼˜å…ˆç ”ç©¶
- **æ‰‹åŠ¨æ§åˆ¶** - å¯éšæ—¶æš‚åœ/å¯ç”¨è‡ªåŠ¨ç ”ç©¶

### **ğŸ“Š é˜Ÿåˆ—çŠ¶æ€æ˜¾ç¤º**

- **è¿›åº¦å¯è§†åŒ–** - å®æ—¶æ˜¾ç¤ºæ¯ä¸ªé¡¹ç›®çš„ç ”ç©¶è¿›åº¦
- **æ—¶é—´é¢„ä¼°** - æ˜¾ç¤ºå•ä¸ªé¡¹ç›®å’Œæ•´ä¸ªé˜Ÿåˆ—çš„å®Œæˆæ—¶é—´
- **çŠ¶æ€å›¾æ ‡** - æ¸…æ™°çš„è§†è§‰çŠ¶æ€æŒ‡ç¤ºï¼ˆè¿›è¡Œä¸­/ç­‰å¾…/é˜»å¡ï¼‰
- **ç»Ÿè®¡ä¿¡æ¯** - é˜Ÿåˆ—é•¿åº¦ã€æ€»æ—¶é—´ã€é¢„è®¡å®Œæˆæ—¶é—´

### **ğŸ® ç”¨æˆ·äº¤äº’**

- **å¿«é€Ÿæ·»åŠ ** - å³é”®ç§‘æŠ€èŠ‚ç‚¹ç›´æ¥åŠ å…¥é˜Ÿåˆ—
- **æ‰¹é‡æ“ä½œ** - æ”¯æŒé€‰æ‹©å¤šä¸ªç§‘æŠ€æ‰¹é‡åŠ å…¥
- **é˜Ÿåˆ—é¢„è§ˆ** - é¼ æ ‡æ‚¬åœæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
- **ä¸€é”®æ¸…ç©º** - å¿«é€Ÿæ¸…ç©ºæ•´ä¸ªç ”ç©¶é˜Ÿåˆ—

é€šè¿‡å®æ–½è¿™ä¸ªè®¾è®¡ï¼Œå¼‚æ˜Ÿå·¥å‚v2é¡¹ç›®å°†æ‹¥æœ‰ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€ç”¨æˆ·å‹å¥½çš„ç§‘æŠ€ç³»ç»Ÿï¼Œä¸ºæ•´ä¸ªæ¸¸æˆçš„è¿›ç¨‹æ§åˆ¶å’Œå†…å®¹è§£é”æä¾›åšå®çš„åŸºç¡€ã€‚
