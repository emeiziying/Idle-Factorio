# 第一阶段：基础自动化系统实现指南

## 目标概述

第一阶段的核心目标是建立一个基础的自动化生产系统，实现：
- 设施自动从库存获取原料
- 自动生产和处理配方
- 产出物品自动存入库存
- 基础的UI界面和交互

## 项目结构

```
demo/
├── src/
│   ├── components/          # UI组件
│   │   ├── GameMap/        # 游戏地图组件
│   │   ├── Inventory/      # 库存界面
│   │   ├── Facility/       # 设施组件
│   │   └── ProductionQueue/ # 生产队列
│   ├── core/               # 核心游戏逻辑
│   │   ├── entities/       # 实体类
│   │   ├── systems/        # 游戏系统
│   │   └── managers/       # 管理器
│   ├── services/           # 服务层
│   │   ├── InventoryService.ts
│   │   ├── ProductionService.ts
│   │   └── FacilityService.ts
│   ├── types/              # 类型定义
│   │   ├── items.ts
│   │   ├── facilities.ts
│   │   └── recipes.ts
│   └── utils/              # 工具函数
```

## 核心数据模型

### 1. 物品系统

```typescript
// types/items.ts
export interface Item {
  id: string;
  name: string;
  category: ItemCategory;
  stackSize: number;
  icon: string;
  description: string;
}

export enum ItemCategory {
  RAW_MATERIAL = 'raw_material',
  INTERMEDIATE = 'intermediate',
  FINISHED = 'finished',
  FUEL = 'fuel'
}

export interface ItemStack {
  itemId: string;
  quantity: number;
}
```

### 2. 设施系统

```typescript
// types/facilities.ts
export interface Facility {
  id: string;
  type: FacilityType;
  position: Position;
  rotation: number;
  recipe: Recipe | null;
  inputBuffer: ItemStack[];
  outputBuffer: ItemStack[];
  productionProgress: number;
  isActive: boolean;
  isPowered: boolean;
}

export enum FacilityType {
  MINER = 'miner',
  FURNACE = 'furnace',
  ASSEMBLER = 'assembler',
  CHEMICAL_PLANT = 'chemical_plant',
  STORAGE = 'storage'
}

export interface Position {
  x: number;
  y: number;
}
```

### 3. 配方系统

```typescript
// types/recipes.ts
export interface Recipe {
  id: string;
  name: string;
  category: RecipeCategory;
  inputs: ItemRequirement[];
  outputs: ItemOutput[];
  productionTime: number; // 秒
  energyRequired: number; // 单位能量
  allowedFacilities: FacilityType[];
}

export interface ItemRequirement {
  itemId: string;
  quantity: number;
}

export interface ItemOutput {
  itemId: string;
  quantity: number;
  probability?: number; // 可选，用于副产品
}
```

## 核心服务实现

### 1. 库存服务

```typescript
// services/InventoryService.ts
export class InventoryService {
  private inventory: Map<string, number> = new Map();
  private capacity: number = 1000;

  // 添加物品到库存
  addItems(itemId: string, quantity: number): boolean {
    const currentQuantity = this.inventory.get(itemId) || 0;
    const newQuantity = currentQuantity + quantity;
    
    if (this.canStore(itemId, quantity)) {
      this.inventory.set(itemId, newQuantity);
      return true;
    }
    return false;
  }

  // 从库存移除物品
  removeItems(itemId: string, quantity: number): boolean {
    const currentQuantity = this.inventory.get(itemId) || 0;
    
    if (currentQuantity >= quantity) {
      this.inventory.set(itemId, currentQuantity - quantity);
      if (currentQuantity - quantity === 0) {
        this.inventory.delete(itemId);
      }
      return true;
    }
    return false;
  }

  // 检查是否有足够的物品
  hasItems(requirements: ItemRequirement[]): boolean {
    return requirements.every(req => 
      (this.inventory.get(req.itemId) || 0) >= req.quantity
    );
  }

  // 批量消耗物品
  consumeItems(requirements: ItemRequirement[]): boolean {
    // 先检查是否都满足
    if (!this.hasItems(requirements)) {
      return false;
    }

    // 执行消耗
    requirements.forEach(req => {
      this.removeItems(req.itemId, req.quantity);
    });

    return true;
  }

  // 获取库存状态
  getInventoryState(): ItemStack[] {
    return Array.from(this.inventory.entries()).map(([itemId, quantity]) => ({
      itemId,
      quantity
    }));
  }

  // 检查是否可以存储
  private canStore(itemId: string, quantity: number): boolean {
    const totalItems = Array.from(this.inventory.values())
      .reduce((sum, qty) => sum + qty, 0);
    return totalItems + quantity <= this.capacity;
  }
}
```

### 2. 生产服务

```typescript
// services/ProductionService.ts
export class ProductionService {
  private facilities: Map<string, Facility> = new Map();
  private inventoryService: InventoryService;

  constructor(inventoryService: InventoryService) {
    this.inventoryService = inventoryService;
  }

  // 更新所有设施的生产
  updateProduction(deltaTime: number): void {
    this.facilities.forEach(facility => {
      if (facility.isActive && facility.isPowered && facility.recipe) {
        this.updateFacilityProduction(facility, deltaTime);
      }
    });
  }

  // 更新单个设施的生产
  private updateFacilityProduction(facility: Facility, deltaTime: number): void {
    const recipe = facility.recipe;
    if (!recipe) return;

    // 检查输入缓冲区
    if (this.needsInput(facility)) {
      this.fetchInputFromInventory(facility);
    }

    // 如果有足够的输入，进行生产
    if (this.hasRequiredInput(facility)) {
      facility.productionProgress += deltaTime / recipe.productionTime;

      // 生产完成
      if (facility.productionProgress >= 1) {
        this.completeProduction(facility);
        facility.productionProgress = 0;
      }
    }

    // 尝试输出到库存
    this.outputToInventory(facility);
  }

  // 检查是否需要输入
  private needsInput(facility: Facility): boolean {
    if (!facility.recipe) return false;
    
    return facility.recipe.inputs.some(input => {
      const buffer = facility.inputBuffer.find(item => item.itemId === input.itemId);
      return !buffer || buffer.quantity < input.quantity;
    });
  }

  // 从库存获取输入
  private fetchInputFromInventory(facility: Facility): void {
    if (!facility.recipe) return;

    facility.recipe.inputs.forEach(input => {
      const buffer = facility.inputBuffer.find(item => item.itemId === input.itemId);
      const currentQuantity = buffer?.quantity || 0;
      const needed = input.quantity - currentQuantity;

      if (needed > 0) {
        // 尝试从库存获取
        const fetched = Math.min(needed, input.quantity * 5); // 一次最多获取5倍需求
        if (this.inventoryService.removeItems(input.itemId, fetched)) {
          if (buffer) {
            buffer.quantity += fetched;
          } else {
            facility.inputBuffer.push({
              itemId: input.itemId,
              quantity: fetched
            });
          }
        }
      }
    });
  }

  // 检查是否有足够的输入
  private hasRequiredInput(facility: Facility): boolean {
    if (!facility.recipe) return false;

    return facility.recipe.inputs.every(input => {
      const buffer = facility.inputBuffer.find(item => item.itemId === input.itemId);
      return buffer && buffer.quantity >= input.quantity;
    });
  }

  // 完成生产
  private completeProduction(facility: Facility): void {
    if (!facility.recipe) return;

    // 消耗输入
    facility.recipe.inputs.forEach(input => {
      const buffer = facility.inputBuffer.find(item => item.itemId === input.itemId);
      if (buffer) {
        buffer.quantity -= input.quantity;
      }
    });

    // 生成输出
    facility.recipe.outputs.forEach(output => {
      const buffer = facility.outputBuffer.find(item => item.itemId === output.itemId);
      if (buffer) {
        buffer.quantity += output.quantity;
      } else {
        facility.outputBuffer.push({
          itemId: output.itemId,
          quantity: output.quantity
        });
      }
    });
  }

  // 输出到库存
  private outputToInventory(facility: Facility): void {
    facility.outputBuffer = facility.outputBuffer.filter(item => {
      if (item.quantity > 0) {
        const added = this.inventoryService.addItems(item.itemId, item.quantity);
        if (added) {
          return false; // 成功添加，从缓冲区移除
        }
      }
      return true; // 保留在缓冲区
    });
  }

  // 添加设施
  addFacility(facility: Facility): void {
    this.facilities.set(facility.id, facility);
  }

  // 移除设施
  removeFacility(facilityId: string): void {
    this.facilities.delete(facilityId);
  }

  // 设置设施配方
  setFacilityRecipe(facilityId: string, recipe: Recipe): void {
    const facility = this.facilities.get(facilityId);
    if (facility && recipe.allowedFacilities.includes(facility.type)) {
      facility.recipe = recipe;
      facility.productionProgress = 0;
    }
  }
}
```

## UI组件实现

### 1. 游戏地图组件

```typescript
// components/GameMap/GameMap.tsx
import React, { useRef, useEffect, useState } from 'react';
import { Box } from '@mui/material';
import { Facility, Position } from '../../types/facilities';

interface GameMapProps {
  facilities: Facility[];
  onFacilityClick: (facility: Facility) => void;
  onMapClick: (position: Position) => void;
}

export const GameMap: React.FC<GameMapProps> = ({
  facilities,
  onFacilityClick,
  onMapClick
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [camera, setCamera] = useState({ x: 0, y: 0, zoom: 1 });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // 清空画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 应用相机变换
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);

    // 绘制网格
    drawGrid(ctx, canvas.width, canvas.height);

    // 绘制设施
    facilities.forEach(facility => {
      drawFacility(ctx, facility);
    });

    ctx.restore();
  }, [facilities, camera]);

  const drawGrid = (ctx: CanvasRenderingContext2D, width: number, height: number) => {
    const gridSize = 32;
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 0.5;

    for (let x = -width; x <= width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, -height);
      ctx.lineTo(x, height);
      ctx.stroke();
    }

    for (let y = -height; y <= height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(-width, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
  };

  const drawFacility = (ctx: CanvasRenderingContext2D, facility: Facility) => {
    const size = 32;
    const x = facility.position.x * size;
    const y = facility.position.y * size;

    // 绘制设施背景
    ctx.fillStyle = facility.isActive ? '#4CAF50' : '#757575';
    ctx.fillRect(x, y, size, size);

    // 绘制边框
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, size, size);

    // 绘制生产进度
    if (facility.productionProgress > 0) {
      ctx.fillStyle = '#FFC107';
      ctx.fillRect(x, y + size - 4, size * facility.productionProgress, 4);
    }
  };

  const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // 转换到世界坐标
    const worldX = (x - canvas.width / 2) / camera.zoom + camera.x;
    const worldY = (y - canvas.height / 2) / camera.zoom + camera.y;

    // 检查是否点击了设施
    const gridX = Math.floor(worldX / 32);
    const gridY = Math.floor(worldY / 32);

    const clickedFacility = facilities.find(f => 
      f.position.x === gridX && f.position.y === gridY
    );

    if (clickedFacility) {
      onFacilityClick(clickedFacility);
    } else {
      onMapClick({ x: gridX, y: gridY });
    }
  };

  return (
    <Box sx={{ width: '100%', height: '100%', position: 'relative' }}>
      <canvas
        ref={canvasRef}
        width={800}
        height={600}
        onClick={handleCanvasClick}
        style={{ 
          border: '1px solid #ccc',
          cursor: 'pointer'
        }}
      />
    </Box>
  );
};
```

### 2. 库存界面组件

```typescript
// components/Inventory/InventoryPanel.tsx
import React from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  List, 
  ListItem, 
  ListItemText,
  ListItemIcon,
  Chip
} from '@mui/material';
import { ItemStack } from '../../types/items';

interface InventoryPanelProps {
  inventory: ItemStack[];
  capacity: number;
  usedSpace: number;
}

export const InventoryPanel: React.FC<InventoryPanelProps> = ({
  inventory,
  capacity,
  usedSpace
}) => {
  return (
    <Paper sx={{ p: 2, height: '100%', overflow: 'auto' }}>
      <Typography variant="h6" gutterBottom>
        库存 ({usedSpace}/{capacity})
      </Typography>
      
      <Box sx={{ mb: 2 }}>
        <Box sx={{ 
          width: '100%', 
          height: 8, 
          bgcolor: 'grey.300',
          borderRadius: 1,
          overflow: 'hidden'
        }}>
          <Box sx={{ 
            width: `${(usedSpace / capacity) * 100}%`,
            height: '100%',
            bgcolor: usedSpace > capacity * 0.9 ? 'error.main' : 'primary.main',
            transition: 'width 0.3s'
          }} />
        </Box>
      </Box>

      <List dense>
        {inventory.map((item) => (
          <ListItem key={item.itemId}>
            <ListItemIcon>
              {/* 物品图标占位 */}
              <Box sx={{ 
                width: 32, 
                height: 32, 
                bgcolor: 'grey.400',
                borderRadius: 1
              }} />
            </ListItemIcon>
            <ListItemText 
              primary={item.itemId}
              secondary={`数量: ${item.quantity}`}
            />
            <Chip 
              label={item.quantity} 
              size="small"
              color="primary"
            />
          </ListItem>
        ))}
      </List>
    </Paper>
  );
};
```

## 游戏循环实现

```typescript
// core/GameLoop.ts
export class GameLoop {
  private lastTime: number = 0;
  private isRunning: boolean = false;
  private updateCallbacks: ((deltaTime: number) => void)[] = [];

  start(): void {
    this.isRunning = true;
    this.lastTime = performance.now();
    this.loop();
  }

  stop(): void {
    this.isRunning = false;
  }

  addUpdateCallback(callback: (deltaTime: number) => void): void {
    this.updateCallbacks.push(callback);
  }

  private loop = (): void => {
    if (!this.isRunning) return;

    const currentTime = performance.now();
    const deltaTime = (currentTime - this.lastTime) / 1000; // 转换为秒
    this.lastTime = currentTime;

    // 执行所有更新回调
    this.updateCallbacks.forEach(callback => callback(deltaTime));

    requestAnimationFrame(this.loop);
  };
}
```

## 主应用集成

```typescript
// App.tsx
import React, { useState, useEffect } from 'react';
import { Box, Grid } from '@mui/material';
import { GameMap } from './components/GameMap/GameMap';
import { InventoryPanel } from './components/Inventory/InventoryPanel';
import { FacilityPanel } from './components/Facility/FacilityPanel';
import { ProductionService } from './services/ProductionService';
import { InventoryService } from './services/InventoryService';
import { GameLoop } from './core/GameLoop';

function App() {
  const [inventoryService] = useState(() => new InventoryService());
  const [productionService] = useState(() => new ProductionService(inventoryService));
  const [gameLoop] = useState(() => new GameLoop());
  const [facilities, setFacilities] = useState<Facility[]>([]);
  const [inventory, setInventory] = useState<ItemStack[]>([]);
  const [selectedFacility, setSelectedFacility] = useState<Facility | null>(null);

  useEffect(() => {
    // 初始化游戏循环
    gameLoop.addUpdateCallback((deltaTime) => {
      productionService.updateProduction(deltaTime);
      
      // 更新UI状态
      setInventory(inventoryService.getInventoryState());
      setFacilities(Array.from(productionService.getFacilities()));
    });

    gameLoop.start();

    return () => {
      gameLoop.stop();
    };
  }, [gameLoop, productionService, inventoryService]);

  const handleFacilityClick = (facility: Facility) => {
    setSelectedFacility(facility);
  };

  const handleMapClick = (position: Position) => {
    // 放置新设施的逻辑
    console.log('Map clicked at:', position);
  };

  return (
    <Box sx={{ height: '100vh', p: 2 }}>
      <Grid container spacing={2} sx={{ height: '100%' }}>
        <Grid item xs={8}>
          <GameMap 
            facilities={facilities}
            onFacilityClick={handleFacilityClick}
            onMapClick={handleMapClick}
          />
        </Grid>
        <Grid item xs={4}>
          <Grid container direction="column" spacing={2} sx={{ height: '100%' }}>
            <Grid item xs={6}>
              <InventoryPanel 
                inventory={inventory}
                capacity={1000}
                usedSpace={inventory.reduce((sum, item) => sum + item.quantity, 0)}
              />
            </Grid>
            <Grid item xs={6}>
              {selectedFacility && (
                <FacilityPanel 
                  facility={selectedFacility}
                  onRecipeChange={(recipe) => {
                    productionService.setFacilityRecipe(selectedFacility.id, recipe);
                  }}
                />
              )}
            </Grid>
          </Grid>
        </Grid>
      </Grid>
    </Box>
  );
}

export default App;
```

## 测试策略

### 1. 单元测试

```typescript
// services/__tests__/InventoryService.test.ts
describe('InventoryService', () => {
  let service: InventoryService;

  beforeEach(() => {
    service = new InventoryService();
  });

  test('should add items to inventory', () => {
    expect(service.addItems('iron-ore', 10)).toBe(true);
    expect(service.getInventoryState()).toContainEqual({
      itemId: 'iron-ore',
      quantity: 10
    });
  });

  test('should not exceed capacity', () => {
    service.setCapacity(100);
    expect(service.addItems('iron-ore', 101)).toBe(false);
  });

  test('should consume items correctly', () => {
    service.addItems('iron-ore', 20);
    service.addItems('copper-ore', 15);
    
    const consumed = service.consumeItems([
      { itemId: 'iron-ore', quantity: 10 },
      { itemId: 'copper-ore', quantity: 5 }
    ]);
    
    expect(consumed).toBe(true);
    expect(service.getItemQuantity('iron-ore')).toBe(10);
    expect(service.getItemQuantity('copper-ore')).toBe(10);
  });
});
```

### 2. 集成测试

```typescript
// integration/__tests__/ProductionFlow.test.ts
describe('Production Flow Integration', () => {
  test('complete production cycle', () => {
    const inventoryService = new InventoryService();
    const productionService = new ProductionService(inventoryService);
    
    // 添加原料
    inventoryService.addItems('iron-ore', 100);
    
    // 创建熔炉
    const furnace: Facility = {
      id: 'furnace-1',
      type: FacilityType.FURNACE,
      position: { x: 0, y: 0 },
      recipe: ironPlateRecipe,
      // ... 其他属性
    };
    
    productionService.addFacility(furnace);
    
    // 模拟10秒生产
    for (let i = 0; i < 100; i++) {
      productionService.updateProduction(0.1);
    }
    
    // 验证产出
    expect(inventoryService.getItemQuantity('iron-plate')).toBeGreaterThan(0);
  });
});
```

## 性能优化建议

1. **渲染优化**
   - 使用脏矩形更新，只重绘变化的部分
   - 实现视口剔除，只渲染可见的设施
   - 使用图片精灵表减少绘制调用

2. **数据结构优化**
   - 使用空间索引（四叉树）快速查找设施
   - 缓存频繁计算的结果
   - 使用对象池减少垃圾回收

3. **更新优化**
   - 分帧更新大量设施
   - 使用Web Workers处理复杂计算
   - 实现LOD系统，远处设施降低更新频率

## 下一步计划

完成第一阶段后，可以开始准备第二阶段的开发：

1. **数据持久化**
   - 实现游戏存档功能
   - 添加自动保存

2. **更多设施类型**
   - 实现不同类型的生产设施
   - 添加电力系统

3. **UI增强**
   - 添加更多交互功能
   - 实现拖拽放置
   - 添加快捷键支持

4. **为第二阶段准备**
   - 预留物流系统接口
   - 设计可扩展的设施连接系统