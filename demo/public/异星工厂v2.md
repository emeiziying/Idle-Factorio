# 异星工厂手机版 PRD - 更新版本

## 1. 产品概述

### 1.1 产品定位

基于经典 PC 游戏《Factorio》设计的移动端工厂自动化管理游戏，采用以物品为中心的简化界面设计，支持多设备类型生产和完全自动化的资源管理系统。

### 1.2 核心特色

- **以物品为中心**的工厂管理界面
- **多设备类型**支持同一物品的不同生产方式
- **完全自动化**的资源管理（设备自动获取燃料和原料）
- **简化界面**专注核心数据和操作
- **本地存储**支持完全离线游戏体验

### 1.3 目标用户

- **核心用户**：25-44 岁策略游戏爱好者
- **移动用户**：偏好简洁界面的手机游戏玩家
- **Factorio 粉丝**：熟悉原版游戏机制的玩家

## 2. 功能需求规格

### 2.1 物品分类系统

#### 2.1.1 基于 Factorio 的六大分类体系

```
物品分类结构（基于Factorio 1.1.107数据）：
├── 物流系统 (Logistics) 📦
│   ├── 传送设备：传送带、地下传送带、分流器
│   ├── 搬运设备：机械臂、快速机械臂、堆叠机械臂
│   ├── 存储设备：箱子、储液罐、物流箱子
│   ├── 运输设备：火车、车厢、轨道信号
│   └── 特性：自动化物流核心，支持物品传输和存储
│
├── 生产系统 (Production) 🏭
│   ├── 开采设备：热力采掘机、电力采掘机
│   ├── 冶炼设备：石质熔炉、钢质熔炉、电炉
│   ├── 装配设备：装配机1-3型、化工厂、炼油厂
│   ├── 发电设备：蒸汽机、太阳能板、核反应堆
│   └── 特性：自动化生产核心，支持资源加工和制造
│
├── 中间产品 (Intermediate Products) ⚙️
│   ├── 金属制品：铁板、铜板、钢板、石砖
│   ├── 机械组件：铁齿轮、铜线、电路板、高级电路
│   ├── 化工产品：塑料、硫酸、润滑油、电池
│   ├── 燃料产品：固体燃料、火箭燃料、核燃料
│   └── 特性：生产链中间环节，用于制造更高级物品
│
├── 战斗系统 (Combat) ⚔️
│   ├── 武器系统：手枪、冲锋枪、火箭筒、火焰喷射器
│   ├── 弹药系统：弹夹、爆炸弹夹、铀弹夹
│   ├── 防护设备：轻型护甲、重型护甲、模块化护甲
│   ├── 防御设施：炮塔、激光炮塔、火焰炮塔
│   └── 特性：军事防御和攻击系统
│
├── 流体系统 (Fluids) 🌊
│   ├── 基础流体：水、原油、蒸汽
│   ├── 加工流体：重油、轻油、石油气
│   ├── 化工流体：硫酸、润滑油
│   ├── 特殊流体：核燃料、铀燃料
│   └── 特性：流体资源管理，支持化工生产
│
└── 科技系统 (Technology) 🧪
    ├── 科技包：自动化、物流、军事、化学、生产、实用、太空科技包
    ├── 研究设施：实验室
    ├── 科技升级：武器伤害、射击速度、机器人速度等
    └── 特性：科技研发和解锁系统，推动游戏进程
```

#### 2.1.2 基于 Factorio 的分类功能要求

- **Tab 切换**：横向滚动标签栏，支持 6 个基于 Factorio 的分类
- **图标识别**：每个分类有独特的图标和颜色，基于 Factorio 设计
- **状态指示**：显示该分类物品的生产状态和科技解锁状态
- **快速定位**：点击分类快速跳转到对应物品
- **科技关联**：显示分类中已解锁和未解锁的物品
- **配方预览**：显示分类中可用的配方数量

```typescript
// 基于Factorio的分类标签配置
const categoryTabs = [
  {
    id: "logistics",
    name: "物流系统",
    icon: "📦",
    color: "#22C55E",
    description: "传送带、机械臂、箱子等物流设备",
  },
  {
    id: "production",
    name: "生产系统",
    icon: "🏭",
    color: "#EAB308",
    description: "熔炉、装配机、采掘机等生产设备",
  },
  {
    id: "intermediate-products",
    name: "中间产品",
    icon: "⚙️",
    color: "#3B82F6",
    description: "铁板、铜板、电路板等中间产品",
  },
  {
    id: "combat",
    name: "战斗系统",
    icon: "⚔️",
    color: "#EF4444",
    description: "武器、弹药、护甲等军事装备",
  },
  {
    id: "fluids",
    name: "流体系统",
    icon: "🌊",
    color: "#06B6D4",
    description: "水、油、蒸汽等流体资源",
  },
  {
    id: "technology",
    name: "科技系统",
    icon: "🧪",
    color: "#8B5CF6",
    description: "科技包、实验室等研究设施",
  },
];
```

### 2.2 物品网格界面

#### 2.2.1 网格布局设计

```
网格布局规范：
├── 基础布局：4列 × N行
├── 卡片尺寸：80×100px
├── 间距设置：3px物品间距，12px行间距
├── 滚动区域：垂直滚动，支持惯性滚动
└── 响应式：自适应不同屏幕宽度
```

#### 2.2.2 物品卡片设计

```
物品卡片结构（优化版）：
┌─────────────────┐
│  [状态指示]      │ ← 状态徽章（右上角）
│                 │
│   [彩色图标]     │ ← 物品图标（中央）
│                 │
│   物品名称       │ ← 名称（底部）
│   245个         │ ← 库存数量
└─────────────────┘
```

**状态徽章设计：**
- **生产中**：绿色圆点 ● (表示正在生产)
- **停产中**：灰色圆点 ○ (表示设备停止)
- **缺料中**：橙色圆点 ⚠ (表示材料不足)
- **库存满**：红色圆点 🔴 (表示库存已满)
- **研究中**：紫色圆点 🔬 (表示科技研发中)
- **无状态**：不显示徽章 (正常状态)

#### 2.2.3 视觉设计规范

- **图标颜色**：每类物品有独特的背景色系
- **状态徽章**：右上角小圆点，显示物品当前状态
- **库存显示**：底部显示具体数量，提供精确信息
- **状态指示**：生产中、停产、缺料等状态用不同颜色边框
- **交互反馈**：点击时卡片阴影加深，提供视觉反馈

**状态徽章颜色规范：**
- **生产中**：#10B981 (绿色) - 设备正在运行
- **停产中**：#6B7280 (灰色) - 设备停止工作
- **缺料中**：#F59E0B (橙色) - 材料不足
- **库存满**：#EF4444 (红色) - 库存已满，停止生产
- **研究中**：#8B5CF6 (紫色) - 科技研发中
- **维护中**：#DC2626 (深红色) - 设备需要维护

**状态徽章实现逻辑：**
```typescript
interface ItemCardState {
  // 状态优先级（从高到低）
  priority: {
    maintenance: 1,    // 维护中 - 最高优先级
    inventoryFull: 2,  // 库存满 - 高优先级
    researching: 3,    // 研究中
    insufficient: 4,   // 缺料中
    stopped: 5,        // 停产中
    producing: 6,      // 生产中
    normal: 7          // 正常状态 - 最低优先级
  };

  // 状态判断逻辑
  getItemState(itemId: string): ItemState {
    const item = this.getItem(itemId);
    
    // 检查维护状态
    if (this.hasMaintenanceIssues(itemId)) {
      return { type: 'maintenance', color: '#EF4444', icon: '🔧' };
    }
    
    // 检查库存满状态
    if (this.isInventoryFull(itemId)) {
      return { type: 'inventoryFull', color: '#EF4444', icon: '🔴' };
    }
    
    // 检查研究状态
    if (this.isResearching(itemId)) {
      return { type: 'researching', color: '#8B5CF6', icon: '🔬' };
    }
    
    // 检查缺料状态
    if (this.hasInsufficientMaterials(itemId)) {
      return { type: 'insufficient', color: '#F59E0B', icon: '⚠' };
    }
    
    // 检查停产状态
    if (this.isStopped(itemId)) {
      return { type: 'stopped', color: '#6B7280', icon: '○' };
    }
    
    // 检查生产状态
    if (this.isProducing(itemId)) {
      return { type: 'producing', color: '#10B981', icon: '●' };
    }
    
    // 正常状态 - 不显示徽章
    return { type: 'normal', color: 'transparent', icon: '' };
  }
}
```

### 2.3 简化物品详情系统

#### 2.3.1 基于 Factorio 的详情页面结构

```
简化详情页面布局：
┌─────────────────────────────────┐
│ [图标] 物品名称          [×关闭] │
├─────────────────────────────────┤
│ 📊 核心数据区域                  │
│ 库存: 245/1000  净增长: +12.5/秒 │
│ 产量: +15.0/秒  消耗: -2.5/秒   │
│ 科技状态: 已解锁/未解锁         │
├─────────────────────────────────┤
│ 📦 存储管理区域                  │
│ 存储设备: 铁箱子 × 1            │
│ [添加箱子] [移除箱子]           │
├─────────────────────────────────┤
│ 📋 配方信息区域 (条件显示) - 位于物品介绍下方 │
│ 制作时间: 0.5秒  解锁科技: 自动化│
│ 输入: 铁板×8  输出: 铁箱子×1    │
├─────────────────────────────────┤
│ 🔨 手动操作区域 (条件显示)       │
│ [手动开采] [手动制作]           │
├─────────────────────────────────┤
│ 🏭 生产设施列表                  │
│ 热力采掘机  3台  +8.4/秒 [-][+] │
│ 电力采掘机  2台  +10.0/秒 [-][+]│
└─────────────────────────────────┘
```

#### 2.3.2 核心数据区域

**数据项定义：**

- **库存数量**：当前拥有的物品总数
- **库存上限**：通过箱子/储罐提供的最大存储容量
- **净增长量**：每秒实际增长量（产量-消耗量）
- **每秒产量**：所有生产设备的产量总和
- **每秒消耗**：作为其他物品原料的消耗速度

#### 2.3.3 存储管理区域

**存储系统设计：**

```
库存上限管理：
├── 基础存储：每种物品默认100个存储上限
├── 箱子扩容：每个铁箱子增加1000个存储容量
├── 储罐扩容：每个储液罐增加25000个流体容量
├── 自动停止：达到上限时自动停止相关生产设备
└── 溢出保护：防止库存超过上限导致的数据错误
```

**存储设备类型：**

```typescript
interface StorageDevice {
  id: string;
  name: string;
  capacity: number;
  itemType: "solid" | "fluid";
  unlockedBy?: string;
}

const storageDevices: { [id: string]: StorageDevice } = {
  // 固体物品存储
  "iron-chest": {
    id: "iron-chest",
    name: "铁箱子",
    capacity: 1000,
    itemType: "solid",
    unlockedBy: "automation",
  },

  "steel-chest": {
    id: "steel-chest", 
    name: "钢箱子",
    capacity: 2000,
    itemType: "solid",
    unlockedBy: "steel-processing",
  },

  // 流体物品存储
  "storage-tank": {
    id: "storage-tank",
    name: "储液罐",
    capacity: 25000,
    itemType: "fluid",
    unlockedBy: "fluid-handling",
  },
};
```

**存储管理界面：**

```
存储管理区域设计：
┌─────────────────────────────────┐
│ 📦 存储管理                     │
├─────────────────────────────────┤
│ 当前库存: 245/1000              │
│ 存储设备: 铁箱子 × 1            │
│ [添加箱子] [移除箱子]           │
├─────────────────────────────────┤
│ 状态: 生产中 (未达上限)          │
│ 或: 已满 (停止生产)             │
└─────────────────────────────────┘
```

**添加设备时的库存检查：**

```
添加设备流程：
├── 点击添加按钮
├── 检查箱子/储罐库存
│   ├── 有库存：消耗1个箱子，增加存储容量
│   └── 无库存：显示提示"库存不足：需要铁箱子但当前没有库存"
├── 更新存储设备列表
└── 刷新界面显示
```

**按钮状态管理：**

```
按钮状态逻辑：
├── 添加按钮：
│   ├── 有箱子库存：高亮可点击
│   └── 无箱子库存：置灰不可点击
├── 移除按钮：
│   ├── 有存储设备：高亮可点击
│   └── 无存储设备：置灰不可点击
└── 状态提示：
    ├── 库存充足：显示"可添加"
    └── 库存不足：显示"库存不足"
```

**存储管理功能：**

- **添加存储设备**：点击添加按钮，消耗箱子/储罐库存建造存储设备
- **移除存储设备**：点击移除按钮，减少存储容量（需要确认）
- **容量显示**：实时显示当前库存和最大容量
- **状态指示**：显示存储状态（未满/已满）
- **自动管理**：达到上限时自动停止相关生产设备
- **库存检查**：添加设备前检查是否有足够的箱子/储罐库存

**库存上限实现逻辑：**

```typescript
class InventoryLimitManager {
  // 库存上限数据结构
  interface InventoryLimit {
    itemId: string;
    currentAmount: number;
    maxCapacity: number;
    storageDevices: StorageDeviceInstance[];
    isFull: boolean;
  }

  // 检查库存是否达到上限
  checkInventoryLimit(itemId: string): boolean {
    const limit = this.getInventoryLimit(itemId);
    return limit.currentAmount >= limit.maxCapacity;
  }

  // 更新库存上限
  updateInventoryLimit(itemId: string, newAmount: number): void {
    const limit = this.getInventoryLimit(itemId);
    
    // 防止超过上限
    if (newAmount > limit.maxCapacity) {
      newAmount = limit.maxCapacity;
      this.notifyInventoryFull(itemId);
    }
    
    limit.currentAmount = newAmount;
    limit.isFull = newAmount >= limit.maxCapacity;
    
    // 如果达到上限，停止相关生产设备
    if (limit.isFull) {
      this.stopProductionDevices(itemId);
    }
  }

  // 添加存储设备
  addStorageDevice(itemId: string, deviceType: string): boolean {
    const device = storageDevices[deviceType];
    if (!device) return false;
    
    // 检查是否有足够的箱子/储罐库存
    if (!this.hasEnoughStorageDevice(deviceType)) {
      this.notifyInsufficientStorageDevice(deviceType);
      return false;
    }
    
    // 消耗箱子/储罐库存
    this.consumeStorageDevice(deviceType);
    
    // 增加存储容量
    const limit = this.getInventoryLimit(itemId);
    limit.maxCapacity += device.capacity;
    limit.storageDevices.push({
      type: deviceType,
      capacity: device.capacity
    });
    
    return true;
  }

  // 移除存储设备
  removeStorageDevice(itemId: string, deviceIndex: number): boolean {
    const limit = this.getInventoryLimit(itemId);
    const device = limit.storageDevices[deviceIndex];
    
    if (!device) return false;
    
    // 检查移除后是否会导致库存溢出
    const newCapacity = limit.maxCapacity - device.capacity;
    if (limit.currentAmount > newCapacity) {
      this.notifyCannotRemoveDevice(itemId, "库存将溢出");
      return false;
    }
    
    // 移除设备
    limit.maxCapacity -= device.capacity;
    limit.storageDevices.splice(deviceIndex, 1);
    
    return true;
  }

  // 停止生产设备
  private stopProductionDevices(itemId: string): void {
    const devices = this.getProductionDevices(itemId);
    devices.forEach(device => {
      device.working = false;
      device.status = "stopped_full_inventory";
    });
  }

  // 检查是否有足够的存储设备库存
  private hasEnoughStorageDevice(deviceType: string): boolean {
    const currentStock = this.getInventoryAmount(deviceType);
    return currentStock > 0;
  }

  // 消耗存储设备库存
  private consumeStorageDevice(deviceType: string): void {
    this.decreaseInventory(deviceType, 1);
  }

  // 通知存储设备库存不足
  private notifyInsufficientStorageDevice(deviceType: string): void {
    const deviceName = storageDevices[deviceType]?.name || deviceType;
    this.showNotification(`库存不足：需要 ${deviceName} 但当前没有库存`);
  }

  // 获取存储设备库存信息
  getStorageDeviceStockInfo(): StorageDeviceStockInfo[] {
    return Object.keys(storageDevices).map(deviceType => ({
      deviceType,
      deviceName: storageDevices[deviceType].name,
      currentStock: this.getInventoryAmount(deviceType),
      canAdd: this.getInventoryAmount(deviceType) > 0
    }));
  }
}

// 存储设备库存信息接口
interface StorageDeviceStockInfo {
  deviceType: string;
  deviceName: string;
  currentStock: number;
  canAdd: boolean;
}

// 使用示例：为铁板添加铁箱子存储
const ironPlateStorageExample = {
  // 检查铁箱子库存
  ironChestStock: 5, // 当前有5个铁箱子
  
  // 添加存储设备
  addIronChestToIronPlate: () => {
    if (ironChestStock > 0) {
      // 消耗1个铁箱子
      ironChestStock--;
      
      // 为铁板增加1000存储容量
      ironPlateMaxCapacity += 1000;
      
      return { success: true, message: "已添加铁箱子存储" };
    } else {
      return { success: false, message: "库存不足：需要铁箱子但当前没有库存" };
    }
  }
};
```
```

#### 2.3.4 配方信息区域

**显示条件：**
- 物品有制作配方时显示
- 配方已解锁时显示完整信息
- 配方未解锁时显示锁定状态

**信息展示：**
- **制作时间**：配方的基础制作时间
- **解锁科技**：解锁该配方的科技名称
- **输入材料**：制作所需的原材料及数量
- **输出物品**：制作产出的物品及数量
- **制作设备**：可用于制作该配方的设备类型

**基于 Factorio 的计算公式：**

```typescript
// 基于Factorio的生产速率计算
interface ProductionCalculation {
  // 每秒产量计算
  productionPerSecond = Σ(
    设备基础速度 ×
    设备等级系数 ×
    设备效率系数 ×
    模块加成系数 ×
    工作状态系数
  );

  // 每秒消耗计算 (基于配方数据)
  consumptionPerSecond = Σ(
    消耗该物品的配方产量 ×
    配方中该物品的消耗比例
  );

  // 净增长量
  netGrowth = productionPerSecond - consumptionPerSecond;

  // 科技解锁状态
  isUnlocked = 检查科技解锁状态(物品ID);

  // 可用配方
  availableRecipes = 获取可用配方(物品ID);
}

// 示例：铁板的生产计算
const ironPlateCalculation = {
  // 生产设备
  electricMiningDrills: 5, // 5台电力采掘机
  stoneFurnaces: 3,        // 3台石质熔炉

  // 产量计算
  miningProduction: 5 × 0.5 × 1.0 = 2.5 铁矿石/秒,
  smeltingProduction: 3 × 1.0 × 1.0 = 3.0 铁板/秒,

  // 消耗计算 (作为其他物品原料)
  consumption: 计算作为原料的消耗,

  // 净增长
  netGrowth: 3.0 - 消耗量
};
```

#### 2.3.5 手动操作区域

**显示条件：**

- **手动开采**：原材料类物品且可开采时显示
- **手动制作**：有制作配方的物品显示

**操作功能：**

- 点击后添加任务到制作队列
- 显示预计完成时间
- 检查材料充足性

**移动端制作按钮设计：**

```
手动制作按钮布局：
┌─────────────────────────────────┐
│ 🔨 手工制作                     │
├─────────────────────────────────┤
│ [制作1个] [制作5个] [最多制造]   │
│ 材料充足 ✓ 预计时间: 2.5秒      │
└─────────────────────────────────┘
```

**按钮功能：**

- **制作 1 个按钮**：添加 1 个制作任务到队列
- **制作 5 个按钮**：添加 5 个制作任务到队列
- **最多制造按钮**：根据材料数量添加最大可制作数量的任务

**状态显示：**

- 材料充足时按钮高亮，材料不足时按钮置灰
- 显示预计完成时间
- 显示材料消耗提示

#### 2.3.6 生产设施列表

**设施卡片设计：**

```
设施卡片结构：
┌─────────────────────────────────┐
│ 设施名称                        │
│ X台 | 产能: +XX.X/秒             │
│ ●●○ 2/3 运行中     [-] 3 [+]    │
└─────────────────────────────────┘
```

**信息展示：**

- **设施名称**：设备类型名称
- **数量统计**：该类设施的总数量
- **总产能**：该类设施的总产量
- **运行状态**：用彩色圆点显示每台设备状态（绿=运行，红=停止）
- **数量控制**：增减按钮直接调整设施数量

### 2.4 设备自动化管理系统

#### 2.4.1 基于 Factorio 的设备类型定义

```typescript
// 基于Factorio 1.1.107数据的设备类型定义
interface EquipmentType {
  id: string;
  name: string;
  category: "mining" | "smelting" | "assembly" | "chemical" | "research";
  baseSpeed: number;
  powerType: "fuel" | "electric";
  powerConsumption?: number; // kW
  fuelType?: "coal" | "wood" | "solid-fuel";
  cost: { [itemId: string]: number };
  canProduce: string[]; // 可生产的物品ID列表
  efficiency: number;
  unlockedBy?: string; // 解锁科技ID
}

// 主要设备类型定义
const equipmentTypes: { [id: string]: EquipmentType } = {
  // 开采设备
  "burner-mining-drill": {
    id: "burner-mining-drill",
    name: "热力采掘机",
    category: "mining",
    baseSpeed: 0.25,
    powerType: "fuel",
    fuelType: "coal",
    cost: { "stone-furnace": 1, "iron-gear-wheel": 3, "iron-plate": 3 },
    canProduce: ["iron-ore", "copper-ore", "coal", "stone", "uranium-ore"],
    efficiency: 1.0,
  },

  "electric-mining-drill": {
    id: "electric-mining-drill",
    name: "电力采掘机",
    category: "mining",
    baseSpeed: 0.5,
    powerType: "electric",
    powerConsumption: 90,
    cost: { "electronic-circuit": 3, "iron-gear-wheel": 5, "iron-plate": 10 },
    canProduce: ["iron-ore", "copper-ore", "coal", "stone", "uranium-ore"],
    efficiency: 1.0,
    unlockedBy: "automation",
  },

  // 冶炼设备
  "stone-furnace": {
    id: "stone-furnace",
    name: "石质熔炉",
    category: "smelting",
    baseSpeed: 1.0,
    powerType: "fuel",
    fuelType: "coal",
    cost: { stone: 5 },
    canProduce: ["iron-plate", "copper-plate", "steel-plate", "stone-brick"],
    efficiency: 1.0,
  },

  "steel-furnace": {
    id: "steel-furnace",
    name: "钢质熔炉",
    category: "smelting",
    baseSpeed: 2.0,
    powerType: "fuel",
    fuelType: "coal",
    cost: { "steel-plate": 6, "advanced-circuit": 10, "stone-brick": 10 },
    canProduce: ["iron-plate", "copper-plate", "steel-plate", "stone-brick"],
    efficiency: 1.0,
    unlockedBy: "steel-processing",
  },

  "electric-furnace": {
    id: "electric-furnace",
    name: "电炉",
    category: "smelting",
    baseSpeed: 2.0,
    powerType: "electric",
    powerConsumption: 180,
    cost: { "advanced-circuit": 5, "steel-plate": 10, "stone-brick": 10 },
    canProduce: ["iron-plate", "copper-plate", "steel-plate", "stone-brick"],
    efficiency: 1.0,
    unlockedBy: "advanced-material-processing",
  },

  // 装配设备
  "assembling-machine-1": {
    id: "assembling-machine-1",
    name: "装配机1型",
    category: "assembly",
    baseSpeed: 0.5,
    powerType: "electric",
    powerConsumption: 77,
    cost: { "electronic-circuit": 3, "iron-gear-wheel": 5, "iron-plate": 9 },
    canProduce: [], // 可生产所有有配方的物品
    efficiency: 1.0,
    unlockedBy: "automation",
  },

  "assembling-machine-2": {
    id: "assembling-machine-2",
    name: "装配机2型",
    category: "assembly",
    baseSpeed: 0.75,
    powerType: "electric",
    powerConsumption: 155,
    cost: {
      "assembling-machine-1": 1,
      "electronic-circuit": 2,
      "iron-gear-wheel": 5,
    },
    canProduce: [], // 可生产所有有配方的物品
    efficiency: 1.0,
    unlockedBy: "automation-2",
  },

  "assembling-machine-3": {
    id: "assembling-machine-3",
    name: "装配机3型",
    category: "assembly",
    baseSpeed: 1.25,
    powerType: "electric",
    powerConsumption: 388,
    cost: {
      "assembling-machine-2": 1,
      "speed-module": 4,
      "advanced-circuit": 2,
    },
    canProduce: [], // 可生产所有有配方的物品
    efficiency: 1.0,
    unlockedBy: "automation-3",
  },

  // 化工设备
  "chemical-plant": {
    id: "chemical-plant",
    name: "化工厂",
    category: "chemical",
    baseSpeed: 1.0,
    powerType: "electric",
    powerConsumption: 210,
    cost: { "steel-plate": 5, "electronic-circuit": 5, "iron-gear-wheel": 5 },
    canProduce: [
      "sulfuric-acid",
      "plastic-bar",
      "sulfur",
      "battery",
      "lubricant",
    ],
    efficiency: 1.0,
    unlockedBy: "oil-processing",
  },

  "oil-refinery": {
    id: "oil-refinery",
    name: "炼油厂",
    category: "chemical",
    baseSpeed: 1.0,
    powerType: "electric",
    powerConsumption: 420,
    cost: {
      "steel-plate": 10,
      "electronic-circuit": 10,
      "iron-gear-wheel": 10,
    },
    canProduce: ["heavy-oil", "light-oil", "petroleum-gas"],
    efficiency: 1.0,
    unlockedBy: "oil-processing",
  },

  // 研究设备
  lab: {
    id: "lab",
    name: "实验室",
    category: "research",
    baseSpeed: 1.0,
    powerType: "electric",
    powerConsumption: 60,
    cost: {
      "electronic-circuit": 10,
      "iron-gear-wheel": 4,
      "transport-belt": 4,
    },
    canProduce: [], // 只用于科技研究
    efficiency: 1.0,
    unlockedBy: "automation",
  },
};
```

#### 2.4.2 基于 Factorio 的配方数据结构

```typescript
// 基于Factorio 1.1.107数据的配方结构
interface Recipe {
  id: string; // 配方唯一ID
  name: string; // 显示名称
  category: string; // 分类 (logistics, production, crafting-with-fluid等)
  row: number; // 科技树行位置
  time: number; // 制作时间(秒)
  producers: string[]; // 可生产此配方的机器列表
  in: { [itemId: string]: number }; // 输入材料及数量
  out: { [itemId: string]: number }; // 输出物品及数量
  unlockedBy?: string; // 解锁此配方的科技ID
}

// 示例配方数据
const recipeExamples: Recipe[] = [
  {
    id: "iron-chest",
    name: "Iron chest",
    category: "logistics",
    row: 0,
    time: 0.5,
    producers: [
      "assembling-machine-1",
      "assembling-machine-2",
      "assembling-machine-3",
    ],
    in: { "iron-plate": 8 },
    out: { "iron-chest": 1 },
  },

  {
    id: "transport-belt",
    name: "Transport belt",
    category: "logistics",
    row: 1,
    time: 0.5,
    producers: [
      "assembling-machine-1",
      "assembling-machine-2",
      "assembling-machine-3",
    ],
    in: { "iron-plate": 1, "iron-gear-wheel": 1 },
    out: { "transport-belt": 2 },
  },

  {
    id: "express-transport-belt",
    name: "Express transport belt",
    category: "crafting-with-fluid",
    row: 1,
    time: 0.5,
    producers: ["assembling-machine-2", "assembling-machine-3"],
    in: { "iron-gear-wheel": 10, "fast-transport-belt": 1, lubricant: 20 },
    out: { "express-transport-belt": 1 },
    unlockedBy: "logistics-3",
  },

  {
    id: "concrete",
    name: "Concrete",
    category: "crafting-with-fluid",
    row: 8,
    time: 10,
    producers: ["assembling-machine-2", "assembling-machine-3"],
    in: { "stone-brick": 5, "iron-ore": 1, water: 100 },
    out: { concrete: 10 },
    unlockedBy: "concrete-technology",
  },
];

// 设备实例数据结构
interface EquipmentInstance {
  id: string; // 唯一标识符
  type: string; // 设备类型ID
  level: number; // 设备等级
  efficiency: number; // 效率系数
  working: boolean; // 工作状态布尔值

  // 燃料设备专有属性
  fuel?: number; // 当前燃料量
  maxFuel?: number; // 最大燃料容量
  fuelType?: string; // 燃料类型

  // 电力设备专有属性
  powerConnected?: boolean; // 电力连接状态
  powerConsumption?: number; // 电力消耗

  // 模块插槽
  modules?: { [slotIndex: number]: ModuleInstance };

  // 状态信息
  lastMaintenance?: number; // 最后维护时间
  totalRuntime?: number; // 总运行时间
  totalProduction?: number; // 总产量
}

// 设备实例管理结构
interface EquipmentManagement {
  [itemId: string]: {
    [equipmentType: string]: EquipmentInstance[];
  };
}
```

#### 2.4.3 完全自动化机制

**燃料自动管理：**

```
燃料自动补充流程：
1. 每100ms检查设备燃料水平
2. 燃料 < 50%最大容量时触发补充
3. 自动从库存中消耗煤炭
4. 按比例转换为设备燃料
5. 库存煤炭不足时设备自动停机
6. 补充煤炭后设备自动重启
```

**原料自动消耗：**

```
原料自动消耗流程：
1. 检查物品制作配方
2. 验证库存原料是否充足
3. 按生产速度比例消耗原料
4. 同步产出目标物品
5. 原料不足时自动停止生产
6. 补充原料后自动恢复生产
```

### 2.5 制作队列系统

#### 2.5.1 队列界面设计

**简化移动端设计：**

```
制作队列布局（简化版）：
┌─────────────────────────────────┐
│ 🔧 制作队列 (3/10)               │
├─────────────────────────────────┤
│  [图标+环形进度] [图标+环形进度] │
│  [图标+环形进度] [图标+环形进度] │
│  [图标+环形进度] [图标+环形进度] │
│  ...（网格排列，最多显示10个）   │
└─────────────────────────────────┘
```

**设计特点：**

- **简洁界面**：只显示图标和环形进度条
- **环形进度**：半透明环形进度条覆盖在图标上
- **点击取消**：点击图标即可取消对应制作任务
- **网格排列**：多个任务以网格形式排列，节省空间
- **进度显示**：环形进度条显示制作进度百分比
- **专注队列**：制作队列界面专注于显示队列状态，制作按钮在物品详情页

**移动端展示方案：**

**方案 1：浮动气泡式设计（推荐）**

```
┌─────────────────────────────────┐
│ 主界面内容                      │
│                                │
│                    [🔧3] ← 浮动 │
│                                │
└─────────────────────────────────┘
```

**浮动气泡特点：**
- **空间效率**：平时只占用很小空间，不遮挡主要内容
- **快速预览**：显示队列数量，用户可快速了解状态
- **按需展开**：点击气泡展开详细队列界面
- **智能显示**：队列为空时自动隐藏气泡
- **可拖拽**：支持拖拽调整位置，避免遮挡重要内容

**展开后的详细界面：**
```
┌─────────────────────────────────┐
│ 🔧 制作队列 (3/10)               │
├─────────────────────────────────┤
│  [图标+环形进度] [图标+环形进度] │
│  [图标+环形进度] [图标+环形进度] │
│  [图标+环形进度] [图标+环形进度] │
│  ...（网格排列，最多显示10个）   │
└─────────────────────────────────┘
```

**推荐方案特点：**
- **浮动气泡**：空间效率最高，用户体验最佳
- **智能显示**：队列为空时隐藏，有任务时显示
- **快速访问**：点击即可查看详细队列
- **可拖拽**：支持手势拖拽调整位置
- **结合展开**：点击气泡展开详细队列界面

#### 2.5.2 队列功能规范

- **容量限制**：最多 10 个任务并发
- **进度显示**：环形进度条显示制作进度百分比
- **状态标识**：制作中、等待中、材料不足等状态（通过进度条颜色区分）
- **取消功能**：点击图标即可取消对应制作任务
- **自动排队**：手动操作自动添加到队列末尾
- **网格布局**：多个任务以网格形式排列，节省屏幕空间

### 2.6 基于 Factorio 的手动生产队列系统

#### 2.6.1 手动生产队列机制

基于[Factorio Wiki](https://wiki.factorio.com/Crafting#Manual_crafting)的官方文档，手动生产队列是玩家通过手动操作来安排物品生产任务的核心系统。

**移动端队列操作方式：**

- **制作 1 个按钮**：点击后队列中添加 1 个制作任务
- **制作 5 个按钮**：点击后队列中添加 5 个制作任务
- **最多制造按钮**：点击后根据当前材料数量，队列中添加最大可制作数量的任务

**队列显示位置：**

- 队列显示在屏幕左下角
- 显示当前正在进行的制作操作
- 可以同时显示多个制作任务

#### 2.6.2 材料预扣机制

```typescript
interface ManualCraftingQueue {
  // 材料预扣
  preemptivelyConsumeMaterials(recipe: Recipe, quantity: number): boolean {
    const requiredMaterials = this.calculateRequiredMaterials(recipe, quantity);

    // 检查库存是否足够
    if (!this.hasEnoughMaterials(requiredMaterials)) {
      return false;
    }

    // 预扣材料
    this.consumeMaterials(requiredMaterials);
    return true;
  }

  // 取消时返还材料
  cancelCraftingAndReturnMaterials(taskId: string): void {
    const task = this.getTask(taskId);
    if (task) {
      // 返还已预扣的材料
      this.returnMaterials(task.consumedMaterials);
      this.removeTask(taskId);
    }
  }
}
```

#### 2.6.3 链式制作支持

```typescript
class ChainCraftingManager {
  // 检查中间产品
  checkIntermediateProducts(recipe: Recipe): IntermediateProduct[] {
    return recipe.ingredients
      .filter((ingredient) => !this.hasEnough(ingredient))
      .map((ingredient) => ({
        itemId: ingredient.itemId,
        required: ingredient.quantity,
        available: this.getAvailable(ingredient.itemId),
        canCraft: this.canCraftItem(ingredient.itemId),
      }));
  }

  // 自动链式制作
  autoChainCraft(targetRecipe: Recipe, quantity: number): CraftingTask[] {
    const tasks: CraftingTask[] = [];
    const intermediateProducts = this.checkIntermediateProducts(targetRecipe);

    intermediateProducts.forEach((product) => {
      if (product.canCraft && product.available < product.required) {
        const needed = product.required - product.available;
        const craftingTask = this.createCraftingTask(product.itemId, needed);
        tasks.push(craftingTask);
      }
    });

    // 添加目标制作任务
    tasks.push(this.createCraftingTask(targetRecipe.id, quantity));
    return tasks;
  }
}
```

#### 2.6.4 取消操作机制

```typescript
class CraftingQueueController {
  // 取消单个制作
  cancelOneCrafting(itemId: string): void {
    const item = this.findQueuedItem(itemId);
    if (item) {
      this.returnMaterials(item.consumedMaterials);
      this.removeFromQueue(item);
    }
  }

  // 取消5个制作
  cancelFiveCrafting(itemId: string): void {
    const items = this.findQueuedItems(itemId, 5);
    items.forEach((item) => {
      this.returnMaterials(item.consumedMaterials);
      this.removeFromQueue(item);
    });
  }

  // 取消所有该物品的制作
  cancelAllCrafting(itemId: string): void {
    const allItems = this.findQueuedItems(itemId);
    allItems.forEach((item) => {
      this.returnMaterials(item.consumedMaterials);
      this.removeFromQueue(item);
    });
  }
}
```

#### 2.6.5 特殊限制和规则

**无法手动制作的物品：**

```typescript
const MANUAL_CRAFTING_RESTRICTIONS = {
  // 矿石只能通过熔炉冶炼
  smeltingOnly: ["iron-ore", "copper-ore", "stone", "coal"],

  // 需要液体的配方
  requiresFluid: ["engine-unit", "electric-engine-unit", "flying-robot-frame"],

  // 必须在组装机中制作
  assemblyMachineOnly: ["engine-unit", "electric-engine-unit"],
};

class ManualCraftingValidator {
  canCraftManually(recipeId: string): boolean {
    const recipe = this.getRecipe(recipeId);

    // 检查是否包含液体
    if (recipe.ingredients.some((ing) => ing.type === "fluid")) {
      return false;
    }

    // 检查是否在限制列表中
    if (MANUAL_CRAFTING_RESTRICTIONS.assemblyMachineOnly.includes(recipe.id)) {
      return false;
    }

    return true;
  }
}
```

**库存满时的处理：**

```typescript
class InventoryCraftingManager {
  // 检查库存空间
  checkInventorySpace(recipe: Recipe, quantity: number): boolean {
    const outputItem = recipe.output;
    const totalOutput = outputItem.quantity * quantity;

    return this.hasEnoughInventorySpace(outputItem.itemId, totalOutput);
  }

  // 库存满时暂停制作
  handleInventoryFull(): void {
    if (this.isInventoryFull()) {
      this.pauseCrafting();
      this.showNotification("库存已满，制作已暂停");
    }
  }
}
```

#### 2.6.6 链式制作优势

```typescript
class ChainCraftingAdvantage {
  // 自动制作中间产品
  autoCraftIntermediates(targetRecipe: Recipe): void {
    const intermediates = this.getRequiredIntermediates(targetRecipe);

    intermediates.forEach((intermediate) => {
      if (!this.hasEnough(intermediate.itemId)) {
        // 自动添加到制作队列
        this.addToCraftingQueue(intermediate.itemId, intermediate.quantity);
      }
    });
  }

  // 与自动化制作的区别
  compareWithAutomation(): string {
    return `
      手动制作优势：
      - 自动链式制作中间产品
      - 无需为每个中间产品设置单独的组装机
      - 更灵活的材料管理
      
      自动化制作限制：
      - 每个制作步骤需要单独的组装机
      - 需要手动设置传送带和机械臂
      - 无法自动链式制作
    `;
  }
}
```

#### 2.6.7 用户界面设计

```typescript
interface ManualCraftingQueueUI {
  // 显示简化制作队列
  displayCraftingQueue(): JSX.Element {
    return (
      <View style={styles.craftingQueue}>
        <Text style={styles.queueTitle}>制作队列 ({this.queue.length}/10)</Text>

        {/* 简化队列显示 - 网格布局 */}
        <View style={styles.queueGrid}>
          {this.queue.map(task => (
            <CraftingTaskIcon
              key={task.id}
              task={task}
              onCancel={() => this.craftingQueue.cancelTask(task.id)}
            />
          ))}
        </View>
      </View>
    );
  }
}

// 底部抽屉式面板组件
interface BottomDrawerProps {
  isVisible: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

const BottomDrawer: React.FC<BottomDrawerProps> = ({
  isVisible,
  onClose,
  children
}) => {
  return (
    <Modal
      visible={isVisible}
      transparent={true}
      animationType="slide"
      onRequestClose={onClose}
    >
      <View style={styles.drawerOverlay}>
        <TouchableOpacity
          style={styles.drawerBackdrop}
          onPress={onClose}
        />
        <View style={styles.drawerContent}>
          {/* 拖拽指示器 */}
          <View style={styles.dragIndicator} />
          {children}
        </View>
      </View>
    </Modal>
  );
};

// 浮动气泡组件（主要推荐方案）
interface FloatingBubbleProps {
  queueCount: number;
  onPress: () => void;
  position?: { x: number; y: number };
  onPositionChange?: (position: { x: number; y: number }) => void;
}

const FloatingBubble: React.FC<FloatingBubbleProps> = ({ 
  queueCount, 
  onPress,
  position = { x: 20, y: 100 },
  onPositionChange
}) => {
  const [bubblePosition, setBubblePosition] = useState(position);
  
  // 队列为空时隐藏气泡
  if (queueCount === 0) return null;
  
  const handlePanGesture = (event: any) => {
    const newPosition = {
      x: event.nativeEvent.pageX - 30, // 30是气泡半径
      y: event.nativeEvent.pageY - 30
    };
    setBubblePosition(newPosition);
    onPositionChange?.(newPosition);
  };
  
  return (
    <PanGestureHandler onGestureEvent={handlePanGesture}>
      <Animated.View style={[styles.floatingBubble, bubblePosition]}>
        <TouchableOpacity onPress={onPress}>
          <Text style={styles.bubbleText}>🔧{queueCount}</Text>
        </TouchableOpacity>
      </Animated.View>
    </PanGestureHandler>
  );
};

// 浮动气泡样式
const styles = StyleSheet.create({
  floatingBubble: {
    position: 'absolute',
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: 'rgba(34, 197, 94, 0.9)', // 绿色半透明
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
    zIndex: 1000,
  },
  bubbleText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
```

// 环形进度条组件
interface CraftingTaskIcon {
task: CraftingTask;
onCancel: () => void;
}

const CraftingTaskIcon: React.FC<CraftingTaskIcon> = ({ task, onCancel }) => {
const progress = task.progress / task.totalTime;

return (
<TouchableOpacity style={styles.taskIcon} onPress={onCancel}>
{/_ 物品图标 _/}
<Image source={getItemIcon(task.itemId)} style={styles.itemIcon} />

      {/* 环形进度条覆盖 */}
      <View style={styles.progressOverlay}>
        <CircularProgress
          progress={progress}
          size={60}
          strokeWidth={4}
          strokeColor={getProgressColor(task.status)}
          backgroundColor="rgba(255,255,255,0.3)"
        />
      </View>

      {/* 进度百分比 */}
      <Text style={styles.progressText}>
        {Math.round(progress * 100)}%
      </Text>
    </TouchableOpacity>

);
};

// 进度条颜色映射
const getProgressColor = (status: string): string => {
switch (status) {
case 'in_progress': return '#22C55E'; // 绿色 - 制作中
case 'waiting': return '#F59E0B'; // 橙色 - 等待中
case 'blocked': return '#EF4444'; // 红色 - 材料不足
default: return '#6B7280'; // 灰色 - 默认
}
};

````

**简化设计规范：**

- **图标尺寸**：60x60px，适合手指点击
- **环形进度**：4px 宽度，半透明背景
- **网格布局**：3 列网格，自适应屏幕宽度
- **点击反馈**：点击时有缩放动画效果
- **进度颜色**：不同状态使用不同颜色区分

### 2.7 基于 Factorio 的科技系统

#### 2.7.1 科技包系统

```typescript
// 基于Factorio 1.1.107的科技包系统
interface SciencePack {
  id: string;
  name: string;
  color: string;
  complexity: number; // 制作复杂度
  time: number; // 制作时间
  cost: { [itemId: string]: number };
}

const sciencePacks: { [id: string]: SciencePack } = {
  "automation-science-pack": {
    id: "automation-science-pack",
    name: "自动化科技包",
    color: "#EF4444",
    complexity: 1,
    time: 5,
    cost: { "copper-plate": 1, "iron-gear-wheel": 1 },
  },

  "logistic-science-pack": {
    id: "logistic-science-pack",
    name: "物流科技包",
    color: "#22C55E",
    complexity: 2,
    time: 6,
    cost: { "transport-belt": 1, inserter: 1 },
  },

  "military-science-pack": {
    id: "military-science-pack",
    name: "军事科技包",
    color: "#8B5CF6",
    complexity: 3,
    time: 10,
    cost: { "piercing-rounds-magazine": 1, grenade: 1, wall: 2 },
  },

  "chemical-science-pack": {
    id: "chemical-science-pack",
    name: "化学科技包",
    color: "#06B6D4",
    complexity: 4,
    time: 24,
    cost: { sulfur: 1, "advanced-circuit": 3, "engine-unit": 2 },
  },

  "production-science-pack": {
    id: "production-science-pack",
    name: "生产科技包",
    color: "#F59E0B",
    complexity: 5,
    time: 21,
    cost: { "electric-furnace": 1, "productivity-module": 1 },
  },

  "utility-science-pack": {
    id: "utility-science-pack",
    name: "实用科技包",
    color: "#10B981",
    complexity: 6,
    time: 21,
    cost: {
      "flying-robot-frame": 1,
      "low-density-structure": 3,
      "processing-unit": 2,
    },
  },

  "space-science-pack": {
    id: "space-science-pack",
    name: "太空科技包",
    color: "#6366F1",
    complexity: 7,
    time: 2000,
    cost: { satellite: 1 }, // 需要发射火箭
  },
};
````

#### 2.7.2 科技数据结构

```typescript
// 基于Factorio的科技结构
interface Technology {
  id: string;
  name: string;
  category: "technology";
  row: number;
  time: number;
  count: number; // 研究所需科技包数量
  producers: ["lab"]; // 只能由实验室研究
  in: { [sciencePackId: string]: number }; // 科技包需求
  out: { [techId: string]: number };
  isTechnology: true;
  prerequisites?: string[]; // 前置科技
  icon?: string; // 图标
  iconText?: string; // 等级文本
}

// 示例科技数据
const technologyExamples: Technology[] = [
  {
    id: "automation",
    name: "Automation",
    category: "technology",
    row: 0,
    time: 15,
    count: 10,
    producers: ["lab"],
    in: { "automation-science-pack": 1 },
    out: { automation: 1 },
    isTechnology: true,
  },

  {
    id: "steel-processing",
    name: "Steel processing",
    category: "technology",
    row: 2,
    time: 5,
    count: 50,
    producers: ["lab"],
    in: { "automation-science-pack": 1 },
    out: { "steel-processing": 1 },
    isTechnology: true,
  },

  {
    id: "logistics-3",
    name: "Logistics 3",
    category: "technology",
    row: 4,
    time: 30,
    count: 200,
    producers: ["lab"],
    in: {
      "automation-science-pack": 1,
      "logistic-science-pack": 1,
      "chemical-science-pack": 1,
    },
    out: { "logistics-3": 1 },
    isTechnology: true,
    prerequisites: ["logistics-2"],
  },
];
```

#### 2.7.3 科技树管理

```typescript
// 科技研究进度管理
interface ResearchProgress {
  techId: string;
  unlocked: boolean; // 是否已解锁
  researched: boolean; // 是否已研究完成
  progress: number; // 研究进度 (0-1)
  currentSciencePacks: { [packId: string]: number }; // 当前投入的科技包
  estimatedTime: number; // 预计完成时间
  isResearching: boolean; // 是否正在研究中
}

// 科技解锁系统
interface TechnologyUnlockSystem {
  unlockedTechnologies: string[]; // 已解锁的科技
  researchedTechnologies: string[]; // 已研究的科技
  availableRecipes: string[]; // 可用的配方
  researchQueue: string[]; // 研究队列
  currentResearch?: ResearchProgress; // 当前研究项目
}
```

### 2.8 库存更新系统

#### 2.8.1 库存精度问题解决方案

在工厂游戏中，库存必须是整数，但生产速率往往不是整数（如 1.5 秒生产 2 个物品，每秒产量为 1.33 个）。采用**累积小数方案**处理此问题。

```typescript
// 生产累积器 - 处理小数产量问题
interface ProductionAccumulator {
  itemId: string; // 物品ID
  accumulatedAmount: number; // 累积的小数部分
  lastUpdateTime: number; // 上次更新时间
  productionRate: number; // 每秒产量
  recipeTime: number; // 配方时间
  outputAmount: number; // 配方输出数量
}

// 库存管理器
class InventoryManager {
  // 更新生产累积器
  updateProductionAccumulator(
    accumulator: ProductionAccumulator,
    currentTime: number
  ): { inventoryChange: number; displayRate: number } {
    const timeDiff = currentTime - accumulator.lastUpdateTime;
    const theoreticalProduction = accumulator.productionRate * timeDiff;

    // 累积小数部分
    accumulator.accumulatedAmount += theoreticalProduction;

    // 计算整数部分
    const integerPart = Math.floor(accumulator.accumulatedAmount);
    const fractionalPart = accumulator.accumulatedAmount - integerPart;

    // 更新累积值
    accumulator.accumulatedAmount = fractionalPart;
    accumulator.lastUpdateTime = currentTime;

    return {
      inventoryChange: integerPart,
      displayRate: accumulator.productionRate,
    };
  }

  // 计算生产速率
  calculateProductionRate(
    recipe: Recipe,
    equipment: EquipmentInstance
  ): number {
    const baseRate = recipe.out[recipe.id] / recipe.time; // 基础速率
    const efficiency = equipment.efficiency || 1.0;
    const workingFactor = equipment.working ? 1.0 : 0.0;

    return baseRate * efficiency * workingFactor;
  }
}
```

#### 2.8.2 多设备生产处理

```typescript
// 处理多个设备生产同一物品
class MultiEquipmentProduction {
  private accumulators: Map<string, ProductionAccumulator> = new Map();

  // 更新所有设备的生产
  updateAllEquipment(currentTime: number): Map<string, number> {
    const inventoryChanges = new Map<string, number>();

    for (const [itemId, accumulator] of this.accumulators) {
      const result = this.updateProductionAccumulator(accumulator, currentTime);

      if (result.inventoryChange > 0) {
        const currentChange = inventoryChanges.get(itemId) || 0;
        inventoryChanges.set(itemId, currentChange + result.inventoryChange);
      }
    }

    return inventoryChanges;
  }

  // 添加生产设备
  addProductionEquipment(
    itemId: string,
    recipe: Recipe,
    equipment: EquipmentInstance
  ) {
    const existing = this.accumulators.get(itemId);
    const newRate = this.calculateProductionRate(recipe, equipment);

    if (existing) {
      // 合并生产速率
      existing.productionRate += newRate;
    } else {
      // 创建新的累积器
      this.accumulators.set(itemId, {
        itemId,
        accumulatedAmount: 0,
        lastUpdateTime: Date.now(),
        productionRate: newRate,
        recipeTime: recipe.time,
        outputAmount: Object.values(recipe.out)[0],
      });
    }
  }
}
```

#### 2.7.3 显示处理方案

```typescript
// 显示逻辑 - 处理非整数产量
class DisplayManager {
  // 格式化产量显示
  formatProductionRate(rate: number): string {
    if (Number.isInteger(rate)) {
      return `${rate}/秒`;
    } else {
      // 显示为分数形式
      const [numerator, denominator] = this.simplifyFraction(rate);
      return `${numerator}/${denominator}秒`;
    }
  }

  // 简化分数
  simplifyFraction(decimal: number): [number, number] {
    // 示例：1.33 -> 4/3
    const tolerance = 0.001;
    let denominator = 1;

    while (
      Math.abs(decimal * denominator - Math.round(decimal * denominator)) >
      tolerance
    ) {
      denominator++;
    }

    return [Math.round(decimal * denominator), denominator];
  }

  // 显示示例
  displayProductionInfo(accumulator: ProductionAccumulator) {
    const rate = accumulator.productionRate;
    const displayRate = this.formatProductionRate(rate);

    console.log(`产量: ${displayRate}`); // 显示: "产量: 4/3秒"
    console.log(`累积: ${accumulator.accumulatedAmount.toFixed(3)}`); // 显示累积的小数部分
  }
}
```

#### 2.7.4 性能优化实现

```typescript
// 优化版本 - 批量更新
class OptimizedInventoryManager {
  private updateInterval = 100; // 100ms更新一次
  private lastBatchUpdate = 0;

  // 批量更新所有生产
  batchUpdate(currentTime: number) {
    if (currentTime - this.lastBatchUpdate < this.updateInterval) {
      return; // 跳过更新
    }

    // 执行批量更新
    this.updateAllProduction(currentTime);
    this.lastBatchUpdate = currentTime;
  }

  // 使用对象池减少内存分配
  private accumulatorPool: ProductionAccumulator[] = [];

  getAccumulator(): ProductionAccumulator {
    return this.accumulatorPool.pop() || this.createNewAccumulator();
  }

  recycleAccumulator(accumulator: ProductionAccumulator) {
    this.accumulatorPool.push(accumulator);
  }
}
```

#### 2.7.5 实际应用示例

```typescript
// 游戏主循环中的使用
class GameLoop {
  private inventoryManager = new InventoryManager();
  private lastUpdateTime = Date.now();

  update() {
    const currentTime = Date.now();
    const deltaTime = currentTime - this.lastUpdateTime;

    // 更新所有生产设备
    const inventoryChanges =
      this.inventoryManager.updateAllProduction(currentTime);

    // 应用库存变化
    for (const [itemId, change] of inventoryChanges) {
      this.gameState.resources[itemId] += change;
    }

    this.lastUpdateTime = currentTime;
  }
}

// 使用示例
const game = new GameLoop();

// 添加铁板生产 (1.5秒生产2个)
game.inventoryManager.addProduction(
  "iron-plate",
  {
    time: 1.5,
    out: { "iron-plate": 2 },
  },
  equipment
);

// 游戏循环中自动处理小数累积
setInterval(() => game.update(), 100); // 100ms更新一次
```

**优势总结：**

- ✅ **精确性**：保持库存为整数，同时准确反映生产进度
- ✅ **性能**：批量更新，减少计算开销
- ✅ **显示**：支持非整数产量的友好显示
- ✅ **扩展性**：支持多设备、多配方、多物品
- ✅ **兼容性**：与 Factorio 原版逻辑一致

### 2.9 本地存储系统

#### 2.9.1 存储架构设计

```
本地存储架构：
├── 主存储：SQLite数据库
│   ├── game_state表：游戏核心状态
│   ├── save_slots表：多存档支持
│   └── user_settings表：用户配置
│
├── 配置存储：SharedPreferences/AsyncStorage
│   ├── 界面设置
│   ├── 游戏偏好
│   └── 最后选择的存档
│
└── 缓存存储：内存缓存
    ├── 当前游戏状态
    ├── 计算结果缓存
    └── 界面状态缓存
```

#### 2.9.2 数据持久化策略

```
自动保存机制：
├── 频率控制：每30秒自动保存
├── 事件触发：重要操作后立即保存
├── 应用生命周期：
│   ├── 进入后台：立即保存
│   ├── 应用退出：强制保存
│   └── 崩溃恢复：定期备份
└── 数据完整性：
    ├── 保存前验证数据有效性
    ├── 保存后校验数据完整性
    └── 损坏时自动恢复机制
```

#### 2.9.3 多存档系统

```
存档管理功能：
├── 存档槽位：支持最多5个存档
├── 存档信息：
│   ├── 存档名称（用户自定义）
│   ├── 游戏进度（等级、时间）
│   ├── 创建时间和最后修改时间
│   └── 存档预览图（可选）
├── 存档操作：
│   ├── 创建新存档
│   ├── 加载指定存档
│   ├── 删除存档
│   ├── 重命名存档
│   └── 导出/导入存档文件
└── 存档保护：
    ├── 删除前二次确认
    ├── 重要存档锁定保护
    └── 意外删除恢复机制
```

## 3. 用户界面设计规范

### 3.1 整体视觉系统

#### 3.1.1 主界面布局

```
主界面结构：
┌─────────────────────────────────┐ ← 状态栏 (64px)
│ 异星工厂  12:34  💰100 💎10 [⏸️] │
├─────────────────────────────────┤ ← 制作队列 (条件显示)
│ 🔧 制作队列 (2/10) [展开/收起]   │
│ [队列任务列表...]               │
├─────────────────────────────────┤ ← 分类标签 (48px)
│ [原材料][中间产品][科学包]...   │
├─────────────────────────────────┤ ← 主要内容区域
│                                 │
│        4×N 物品网格             │
│                                 │
│                                 │
└─────────────────────────────────┘
```

#### 3.1.2 响应式设计规范

```
屏幕适配规范：
├── 最小宽度：320px (iPhone SE)
├── 最大宽度：480px (大屏手机)
├── 安全区域：适配刘海屏和圆角
├── 触摸目标：最小44×44px
└── 字体缩放：支持系统字体大小设置
```

### 3.2 色彩设计系统

#### 3.2.1 基于 Factorio 的主色调定义

```
颜色规范：
├── 主色调：
│   ├── 主色：#2563EB (蓝色) - 主要按钮、链接
│   ├── 成功：#10B981 (绿色) - 成功状态、运行中
│   ├── 警告：#F59E0B (橙色) - 警告状态、燃料相关
│   ├── 错误：#EF4444 (红色) - 错误状态、停止状态
│   └── 中性：#6B7280 (灰色) - 文本、边框
│
├── 基于Factorio的分类色彩：
│   ├── 物流系统 (Logistics)：#22C55E (绿色系) - 传送带、机械臂、箱子
│   ├── 生产系统 (Production)：#EAB308 (黄色系) - 熔炉、装配机、采掘机
│   ├── 中间产品 (Intermediate)：#3B82F6 (蓝色系) - 铁板、铜板、电路板
│   ├── 战斗系统 (Combat)：#EF4444 (红色系) - 武器、弹药、护甲
│   ├── 流体系统 (Fluids)：#06B6D4 (青色系) - 水、油、蒸汽
│   └── 科技系统 (Technology)：#8B5CF6 (紫色系) - 科技包、实验室
│
├── 科技包色彩：
│   ├── 自动化科技包：#EF4444 (红色)
│   ├── 物流科技包：#22C55E (绿色)
│   ├── 军事科技包：#8B5CF6 (紫色)
│   ├── 化学科技包：#06B6D4 (青色)
│   ├── 生产科技包：#F59E0B (橙色)
│   ├── 实用科技包：#10B981 (绿色)
│   └── 太空科技包：#6366F1 (靛蓝色)
│
└── 状态色彩：
    ├── 生产中：#10B981 (绿色)
    ├── 停止中：#EF4444 (红色)
    ├── 缺料中：#F59E0B (橙色)
    ├── 维护中：#6B7280 (灰色)
    ├── 研究中：#8B5CF6 (紫色)
    └── 已解锁：#22C55E (绿色)
```

#### 3.2.2 物品图标色彩

```
物品图标颜色映射：
├── 矿物类：棕色到橙色系
├── 金属类：银色到灰色系
├── 机械类：黄色到金色系
├── 电子类：绿色到蓝色系
├── 化工类：蓝色到紫色系
├── 科技类：紫色到粉色系
└── 军事类：红色到深红系
```

### 3.3 字体和排版规范

#### 3.3.1 字体层级系统

```
字体大小规范：
├── 标题文字：18px, 字重700 (页面标题)
├── 副标题：16px, 字重600 (区域标题)
├── 正文文字：14px, 字重400 (主要文本)
├── 辅助文字：12px, 字重400 (辅助信息)
├── 小号文字：10px, 字重400 (状态标签)
└── 数字文字：14px, 字重600 (数值显示)
```

#### 3.3.2 排版间距规范

```
间距系统：
├── 基础间距：4px (最小间距单位)
├── 组件内间距：8px (按钮内边距)
├── 相关元素间距：12px (相关内容间距)
├── 段落间距：16px (段落之间间距)
├── 区域间距：24px (不同区域间距)
└── 页面间距：32px (页面边距)
```

### 3.4 交互设计规范

#### 3.4.1 触摸交互标准

```
交互行为定义：
├── 点击 (Tap)：
│   ├── 物品卡片：打开物品详情
│   ├── 设施按钮：调整设施数量
│   ├── 分类标签：切换物品分类
│   └── 功能按钮：执行对应功能
│
├── 长按 (Long Press)：
│   ├── 物品卡片：快速操作菜单
│   ├── 设施项目：设施详细信息
│   └── 队列任务：任务管理选项
│
└── 滑动 (Swipe)：
    ├── 水平滑动：切换分类标签
    ├── 垂直滑动：滚动物品列表
    └── 制作队列：滑动删除任务
```

#### 3.4.2 动画和过渡效果

```
动画规范：
├── 页面切换：300ms ease-in-out
├── 弹窗出现：200ms ease-out
├── 按钮点击：100ms ease-in
├── 数值变化：150ms ease-out
├── 进度条：实时更新，无动画
└── 状态切换：200ms ease-in-out
```

### 3.5 组件设计规范

#### 3.5.1 按钮组件规范

```
按钮类型定义：
├── 主要按钮：
│   ├── 背景：#2563EB
│   ├── 文字：#FFFFFF
│   ├── 高度：44px
│   ├── 圆角：8px
│   └── 用途：主要操作
│
├── 次要按钮：
│   ├── 背景：透明
│   ├── 边框：1px #2563EB
│   ├── 文字：#2563EB
│   ├── 高度：44px
│   └── 用途：次要操作
│
├── 危险按钮：
│   ├── 背景：#EF4444
│   ├── 文字：#FFFFFF
│   ├── 高度：44px
│   └── 用途：删除等危险操作
│
└── 图标按钮：
    ├── 尺寸：44×44px
    ├── 背景：透明或浅色
    ├── 图标：24×24px
    └── 用途：工具栏操作
```

#### 3.5.2 卡片组件规范

```
卡片设计规范：
├── 背景色：#FFFFFF
├── 边框：1px #E5E7EB
├── 圆角：8px
├── 阴影：0 1px 3px rgba(0,0,0,0.1)
├── 内边距：12px
├── 悬停效果：阴影加深
└── 点击效果：轻微缩放
```

#### 3.5.3 进度条组件规范

```
进度条设计：
├── 细进度条：
│   ├── 高度：4px
│   ├── 背景：#E5E7EB
│   ├── 前景：根据类型选择
│   └── 圆角：2px
│
└── 粗进度条：
    ├── 高度：8px
    ├── 背景：#E5E7EB
    ├── 前景：根据类型选择
    └── 圆角：4px
```

## 4. 技术实现规范

### 4.1 技术架构选型

#### 4.1.1 前端技术栈

```
推荐技术方案：
├── 主框架：React Native
│   ├── 优势：跨平台、生态成熟、性能优秀
│   ├── 版本：React Native 0.72+
│   └── 语言：TypeScript
│
├── 状态管理：Redux Toolkit
│   ├── 全局状态：游戏核心数据
│   ├── 本地状态：React useState
│   └── 持久化：Redux Persist
│
├── 导航：React Navigation 6
│   ├── 页面导航：Stack Navigator
│   ├── 标签导航：Tab Navigator
│   └── 弹窗导航：Modal Navigator
│
└── UI组件：
    ├── 基础组件：React Native内置
    ├── 图标库：React Native Vector Icons
    └── 动画库：React Native Reanimated
```

#### 4.1.2 数据存储技术

```
存储技术选型：
├── 游戏数据：SQLite
│   ├── 库：react-native-sqlite-storage
│   ├── 优势：结构化存储、查询性能好
│   └── 用途：游戏状态、存档、统计数据
│
├── 配置数据：AsyncStorage
│   ├── 库：@react-native-async-storage/async-storage
│   ├── 优势：简单易用、性能好
│   └── 用途：用户设置、偏好配置
│
├── 缓存数据：内存
│   ├── 实现：JavaScript对象
│   ├── 优势：访问速度最快
│   └── 用途：当前游戏状态、计算结果
│
└── 临时数据：文件系统
    ├── 库：react-native-fs
    ├── 优势：大容量、可导出
    └── 用途：存档备份、日志文件
```

### 4.2 数据结构设计

#### 4.2.1 基于 Factorio 的游戏状态数据结构

```typescript
// 基于Factorio 1.1.107数据的游戏状态结构
interface GameState {
  // 版本信息
  version: {
    base: string; // Factorio版本
    DataRawJson: string; // 数据格式版本
  };

  // 分类定义
  categories: Category[]; // 基于Factorio的分类
  icons: Icon[]; // 图标定义
  items: Item[]; // 物品定义
  recipes: Recipe[]; // 配方定义
  technologies: Technology[]; // 科技定义

  // 玩家信息
  player: {
    id: string;
    level: number;
    experience: number;
    playtime: number;
    currencies: {
      gold: number;
      crystals: number;
    };
  };

  // 资源库存 (基于Factorio物品ID)
  resources: {
    [itemId: string]: number;
  };

  // 设备实例管理
  equipment: EquipmentManagement;

  // 科技研发系统
  research: {
    unlockedTechnologies: string[]; // 已解锁的科技
    researchedTechnologies: string[]; // 已研究的科技
    availableRecipes: string[]; // 可用的配方
    researchQueue: string[]; // 研究队列
    currentResearch?: ResearchProgress; // 当前研究项目
  };

  // 制作队列
  craftingQueue: CraftingTask[];

  // 游戏设置
  settings: {
    autoSave: boolean;
    soundEnabled: boolean;
    vibrationEnabled: boolean;
    selectedCategory: string;
  };

  // 生产率模块限制
  limitations: {
    "productivity-module": string[]; // 不能使用生产率模块的配方
  };

  // 元数据
  metadata: {
    version: string;
    lastSaved: number;
    totalPlaytime: number;
    factorioVersion: string; // 对应的Factorio版本
  };
}

// 物品数据结构 (基于Factorio)
interface Item {
  id: string;
  name: string;
  category: string;
  stack: number; // 堆叠数量
  row: number; // 科技树行位置

  // 特殊属性
  container?: { size: number }; // 容器容量
  belt?: { speed: number }; // 传送带速度
  storageTank?: { capacity: number }; // 储罐容量
  fuel?: { value: number }; // 燃料值
}

// 分类定义 (基于Factorio)
interface Category {
  id: string;
  name: string;
  icon?: string;
}

// 图标定义 (基于Factorio)
interface Icon {
  id: string;
  position: string;
  color: string;
}
```

#### 4.2.2 设备实例数据结构

```typescript
interface EquipmentInstance {
  id: string;
  type: string;
  level: number;
  efficiency: number;
  working: boolean;

  // 燃料设备专有
  fuel?: number;
  maxFuel?: number;
  fuelType?: string;

  // 电力设备专有
  powerConnected?: boolean;
  powerConsumption?: number;

  // 模块插槽
  modules?: {
    [slotIndex: number]: ModuleInstance;
  };

  // 状态信息
  lastMaintenance?: number;
  totalRuntime?: number;
  totalProduction?: number;
}
```

#### 4.2.3 制作任务数据结构

```typescript
interface CraftingTask {
  id: string;
  type: "mining" | "crafting";
  itemId: string;
  quantity: number;
  progress: number;
  totalTime: number;

  // 制作任务专有
  recipeId?: string;
  materialsConsumed?: boolean;

  // 开采任务专有
  miningMethod?: "manual" | "automatic";

  // 状态信息
  createdAt: number;
  startedAt?: number;
  estimatedCompletion?: number;
}
```

### 4.3 性能优化策略

#### 4.3.1 渲染性能优化

```
渲染优化措施：
├── 虚拟化滚动：
│   ├── 使用FlatList代替ScrollView
│   ├── 设置合理的初始渲染数量
│   └── 实现windowSize优化
│
├── 图片优化：
│   ├── 使用适当的图片格式和尺寸
│   ├── 实现图片懒加载
│   └── 缓存频繁使用的图片
│
├── 组件优化：
│   ├── 使用React.memo避免无用渲染
│   ├── 使用useMemo缓存计算结果
│   └── 使用useCallback避免函数重新创建
│
└── 状态管理优化：
    ├── 避免过度的状态更新
    ├── 使用批量更新减少渲染次数
    └── 合理拆分状态避免全局更新
```

#### 4.3.2 内存管理优化

```
内存优化策略：
├── 数据结构优化：
│   ├── 使用合适的数据类型
│   ├── 避免循环引用
│   └── 及时清理不用的数据
│
├── 缓存策略：
│   ├── 设置合理的缓存大小限制
│   ├── 实现LRU缓存淘汰策略
│   └── 定期清理过期缓存
│
├── 对象池：
│   ├── 重用频繁创建的对象
│   ├── 预分配常用对象
│   └── 减少垃圾回收压力
│
└── 监控工具：
    ├── 集成内存使用监控
    ├── 设置内存泄漏警告
    ├── 定期内存使用报告
    └── 性能瓶颈自动检测
```

#### 4.3.3 游戏循环优化

```
游戏循环性能优化：
├── 频率控制：
│   ├── 主循环：100ms (10fps)
│   ├── UI更新：16.67ms (60fps)
│   ├── 数据保存：30s自动保存
│   └── 统计计算：1s更新一次
│
├── 计算优化：
│   ├── 增量计算：只计算变化的部分
│   ├── 批量处理：合并多个小计算
│   ├── 异步计算：复杂计算放入后台
│   └── 缓存结果：缓存重复计算结果
│
├── 更新策略：
│   ├── 脏标记：标记需要更新的数据
│   ├── 优先级：重要数据优先计算
│   ├── 分帧处理：大任务分多帧完成
│   └── 暂停机制：后台时暂停非必要计算
│
└── 资源管理：
    ├── 对象复用：复用临时计算对象
    ├── 延迟初始化：按需创建计算对象
    ├── 自动垃圾回收：定期清理无用对象
    └── 资源预加载：提前加载常用资源
```

### 4.4 数据持久化实现

#### 4.4.1 SQLite 数据库设计

```sql
-- 游戏存档表
CREATE TABLE save_files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    game_data TEXT NOT NULL, -- JSON格式的游戏数据
    preview_image BLOB,      -- 存档预览图
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    version TEXT NOT NULL,
    is_active BOOLEAN DEFAULT FALSE
);

-- 用户设置表
CREATE TABLE user_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    type TEXT NOT NULL -- 'string', 'number', 'boolean', 'json'
);

-- 游戏统计表
CREATE TABLE game_statistics (
    save_id INTEGER,
    stat_name TEXT,
    stat_value REAL,
    recorded_at INTEGER,
    FOREIGN KEY (save_id) REFERENCES save_files(id)
);

-- 成就记录表
CREATE TABLE achievements (
    save_id INTEGER,
    achievement_id TEXT,
    unlocked_at INTEGER,
    progress REAL DEFAULT 0,
    FOREIGN KEY (save_id) REFERENCES save_files(id)
);
```

#### 4.4.2 数据序列化策略

```typescript
// 数据压缩和序列化
class GameDataSerializer {
  // 序列化游戏状态
  static serialize(gameState: GameState): string {
    // 1. 移除冗余数据
    const cleanedState = this.removeRedundantData(gameState);

    // 2. 压缩数据结构
    const compressedState = this.compressData(cleanedState);

    // 3. JSON序列化
    const serialized = JSON.stringify(compressedState);

    // 4. 可选的进一步压缩
    return this.gzipCompress(serialized);
  }

  // 反序列化游戏状态
  static deserialize(data: string): GameState {
    // 1. 解压缩
    const decompressed = this.gzipDecompress(data);

    // 2. JSON解析
    const parsed = JSON.parse(decompressed);

    // 3. 数据解压缩
    const expanded = this.expandData(parsed);

    // 4. 数据验证和修复
    return this.validateAndRepair(expanded);
  }

  // 版本迁移
  static migrate(data: any, fromVersion: string, toVersion: string): GameState {
    const migrations = this.getMigrations(fromVersion, toVersion);
    return migrations.reduce((state, migration) => migration(state), data);
  }
}
```

#### 4.4.3 自动保存机制

```typescript
class AutoSaveManager {
  private saveTimer: NodeJS.Timeout | null = null;
  private pendingSave = false;
  private lastSaveTime = 0;

  // 启动自动保存
  startAutoSave(interval: number = 30000) {
    this.saveTimer = setInterval(() => {
      this.performAutoSave();
    }, interval);
  }

  // 执行自动保存
  private async performAutoSave() {
    if (this.pendingSave) return;

    this.pendingSave = true;
    try {
      const gameState = store.getState().game;
      const hasChanges = this.hasSignificantChanges(gameState);

      if (hasChanges) {
        await this.saveGameState(gameState);
        this.lastSaveTime = Date.now();
      }
    } catch (error) {
      console.error("自动保存失败:", error);
    } finally {
      this.pendingSave = false;
    }
  }

  // 强制保存
  async forceSave(): Promise<void> {
    if (this.saveTimer) {
      clearInterval(this.saveTimer);
    }
    await this.performAutoSave();
    this.startAutoSave();
  }

  // 检查是否有重要变化
  private hasSignificantChanges(gameState: GameState): boolean {
    // 检查资源变化
    // 检查设备状态变化
    // 检查研发进度变化
    // 返回是否需要保存
    return true;
  }
}
```

## 5. 用户体验设计

### 5.1 新手引导系统

#### 5.1.1 引导流程设计

```
新手引导步骤：
├── 第一步：界面介绍 (30秒)
│   ├── 展示主界面各区域功能
│   ├── 说明分类标签的作用
│   └── 介绍物品网格布局
│
├── 第二步：基础操作 (60秒)
│   ├── 点击物品查看详情
│   ├── 尝试手动开采铁矿石
│   └── 观察库存数量变化
│
├── 第三步：自动化入门 (90秒)
│   ├── 建造第一台热力采掘机
│   ├── 观察自动开采过程
│   └── 理解燃料自动补充机制
│
├── 第四步：生产链建立 (120秒)
│   ├── 建造熔炉冶炼铁板
│   ├── 制作第一个铁齿轮
│   └── 完成第一个科技包制作
│
└── 第五步：科技研发 (60秒)
    ├── 使用科技包解锁新技术
    ├── 建造装配机实现自动化
    └── 设置第一条完整生产线
```

#### 5.1.2 引导机制设计

```typescript
interface TutorialStep {
  id: string;
  title: string;
  description: string;
  targetElement?: string;
  highlightArea?: "circle" | "rectangle";
  action?: "tap" | "drag" | "wait";
  condition?: () => boolean;
  onComplete?: () => void;
  skippable: boolean;
}

class TutorialManager {
  private currentStep = 0;
  private steps: TutorialStep[] = [];
  private overlay: React.Component | null = null;

  // 开始引导
  startTutorial(tutorialId: string) {
    this.steps = this.loadTutorialSteps(tutorialId);
    this.showNextStep();
  }

  // 显示下一步
  showNextStep() {
    if (this.currentStep >= this.steps.length) {
      this.completeTutorial();
      return;
    }

    const step = this.steps[this.currentStep];
    this.showStepOverlay(step);
  }

  // 检查步骤完成条件
  checkStepCompletion() {
    const step = this.steps[this.currentStep];
    if (step.condition && step.condition()) {
      this.currentStep++;
      this.showNextStep();
    }
  }
}
```

### 5.2 游戏平衡性设计

#### 5.2.1 进度曲线设计

```
游戏进度平衡：
├── 早期阶段 (0-30分钟)
│   ├── 手动操作为主
│   ├── 资源获取容易
│   ├── 制作时间短
│   └── 快速正反馈
│
├── 发展阶段 (30分钟-2小时)
│   ├── 自动化入门
│   ├── 设备建造成本合理
│   ├── 生产链逐步复杂
│   └── 科技解锁有序
│
├── 扩张阶段 (2-8小时)
│   ├── 大规模自动化
│   ├── 资源需求增加
│   ├── 效率优化挑战
│   └── 高级科技解锁
│
└── 优化阶段 (8小时以上)
    ├── 完全自动化
    ├── 效率极限挑战
    ├── 复杂生产链
    └── 无限扩展可能
```

#### 5.2.2 经济平衡设计

```
资源平衡公式：
├── 基础资源比例：
│   ├── 铁矿石：基准 (1.0)
│   ├── 铜矿石：0.8倍需求
│   ├── 煤炭：0.6倍需求 (但多用途)
│   └── 石头：0.4倍需求
│
├── 设备成本曲线：
│   ├── 基础设备：线性增长
│   ├── 高级设备：指数增长
│   ├── 升级成本：等级^1.5
│   └── 维护成本：固定比例
│
├── 生产效率曲线：
│   ├── 手动效率：1.0倍
│   ├── 基础自动化：5-10倍
│   ├── 高级自动化：50-100倍
│   └── 极限效率：1000倍+
│
└── 科技解锁成本：
    ├── 红色科技：10-50包
    ├── 绿色科技：20-100包
    ├── 蓝色科技：50-200包
    └── 高级科技：100-500包
```

### 5.3 错误处理和用户反馈

#### 5.3.1 错误处理策略

```
错误处理机制：
├── 数据错误：
│   ├── 自动数据验证
│   ├── 损坏数据修复
│   ├── 备份数据恢复
│   └── 默认值填充
│
├── 操作错误：
│   ├── 输入验证
│   ├── 操作确认
│   ├── 撤销功能
│   └── 错误提示
│
├── 系统错误：
│   ├── 异常捕获
│   ├── 错误日志
│   ├── 崩溃恢复
│   └── 降级处理
│
└── 网络错误：
    ├── 离线模式
    ├── 重试机制
    ├── 缓存策略
    └── 同步恢复
```

#### 5.3.2 用户反馈系统

```
反馈机制设计：
├── 即时反馈：
│   ├── 按钮点击效果
│   ├── 数值变化动画
│   ├── 状态指示灯
│   └── 进度条更新
│
├── 操作确认：
│   ├── 成功操作提示
│   ├── 失败原因说明
│   ├── 警告信息展示
│   └── 建议操作指导
│
├── 进度反馈：
│   ├── 制作进度显示
│   ├── 研发进度追踪
│   ├── 建造进度提示
│   └── 升级进度展示
│
└── 系统通知：
    ├── 重要事件通知
    ├── 错误警告提示
    ├── 成就解锁通知
    └── 更新提醒信息
```

## 6. 测试验收标准

### 6.1 功能测试要求

#### 6.1.1 核心功能测试

```
功能测试清单：
├── 物品管理：
│   ✓ 物品分类正确显示
│   ✓ 物品网格布局正确
│   ✓ 物品详情数据准确
│   ✓ 库存数量实时更新
│
├── 设备管理：
│   ✓ 设备建造功能正常
│   ✓ 设备数量调整正确
│   ✓ 设备状态显示准确
│   ✓ 自动化生产正常
│
├── 制作系统：
│   ✓ 手动制作功能正常
│   ✓ 制作队列管理正确
│   ✓ 进度显示准确
│   ✓ 材料消耗正确
│
├── 自动化系统：
│   ✓ 燃料自动补充正常
│   ✓ 原料自动消耗正确
│   ✓ 设备自动启停正常
│   ✓ 生产计算准确
│
└── 数据持久化：
    ✓ 自动保存功能正常
    ✓ 手动保存功能正常
    ✓ 数据加载正确
    ✓ 多存档管理正常
```

#### 6.1.2 边界条件测试

```
边界测试场景：
├── 资源极限：
│   ✓ 库存为0时的处理
│   ✓ 库存达到上限的处理
│   ✓ 负数资源的防护
│   ✓ 超大数值的处理
│
├── 设备极限：
│   ✓ 设备数量为0的处理
│   ✓ 设备数量达到上限
│   ✓ 所有设备停机的情况
│   ✓ 设备效率为0的处理
│
├── 时间极限：
│   ✓ 游戏时间超长的处理
│   ✓ 制作时间为0的处理
│   ✓ 系统时间异常的处理
│   ✓ 离线时间过长的处理
│
└── 数据极限：
    ✓ 存档大小超限的处理
    ✓ 存档数量超限的处理
    ✓ 数据损坏的恢复
    ✓ 版本不兼容的处理
```

### 6.2 性能测试标准

#### 6.2.1 响应时间要求

```
性能基准：
├── 界面响应：
│   ✓ 点击响应 < 100ms
│   ✓ 页面切换 < 300ms
│   ✓ 数据更新 < 200ms
│   ✓ 动画流畅 60fps
│
├── 数据处理：
│   ✓ 游戏循环 < 10ms
│   ✓ 保存操作 < 1000ms
│   ✓ 加载操作 < 3000ms
│   ✓ 计算更新 < 50ms
│
├── 内存使用：
│   ✓ 基础内存 < 100MB
│   ✓ 峰值内存 < 200MB
│   ✓ 内存增长 < 1MB/小时
│   ✓ 内存释放及时
│
└── 电池消耗：
    ✓ 待机模式 < 1%/小时
    ✓ 活跃模式 < 10%/小时
    ✓ 后台模式 < 2%/小时
    ✓ 充电时无过热
```

#### 6.2.2 压力测试要求

```
压力测试场景：
├── 数据量压力：
│   ✓ 1000+ 设备实例
│   ✓ 10000+ 物品库存
│   ✓ 100+ 制作队列任务
│   ✓ 长时间连续运行
│
├── 操作频率压力：
│   ✓ 快速点击测试
│   ✓ 大量并发操作
│   ✓ 频繁保存加载
│   ✓ 快速切换界面
│
├── 资源压力：
│   ✓ 低内存设备测试
│   ✓ 存储空间不足测试
│   ✓ 电量不足测试
│   ✓ 网络不稳定测试
│
└── 时间压力：
    ✓ 7×24小时稳定运行
    ✓ 频繁前后台切换
    ✓ 长期数据累积
    ✓ 系统资源竞争
```

### 6.3 兼容性测试要求

#### 6.3.1 设备兼容性

```
设备测试矩阵：
├── iOS设备：
│   ✓ iPhone SE (4.7")
│   ✓ iPhone 12 (6.1")
│   ✓ iPhone 12 Pro Max (6.7")
│   ✓ iPad (10.2")
│
├── Android设备：
│   ✓ 小屏设备 (5.0"-5.5")
│   ✓ 标准设备 (5.5"-6.0")
│   ✓ 大屏设备 (6.0"-6.7")
│   ✓ 平板设备 (7"+)
│
├── 系统版本：
│   ✓ iOS 12+ (最低支持)
│   ✓ iOS 15+ (推荐)
│   ✓ Android 7+ (最低支持)
│   ✓ Android 10+ (推荐)
│
└── 硬件配置：
    ✓ 2GB RAM (最低)
    ✓ 4GB RAM (推荐)
    ✓ 32GB 存储 (最低)
    ✓ 64GB 存储 (推荐)
```

## 7. 发布和维护计划

### 7.1 版本发布计划

#### 7.1.1 MVP 版本 (v1.0)

```
v1.0 功能清单：
├── 核心功能 (必须):
│   ✓ 7大分类物品管理
│   ✓ 简化物品详情页面
│   ✓ 基础设备管理
│   ✓ 手动和自动生产
│   ✓ 本地存储系统
│
├── 基础功能 (必须):
│   ✓ 制作队列系统
│   ✓ 科技研发系统
│   ✓ 新手引导系统
│   ✓ 基础设置功能
│
├── 优化功能 (可选):
│   ✓ 性能优化
│   ✓ 动画效果
│   ✓ 音效支持
│   ✓ 多语言支持
│
└── 发布目标:
    ✓ iOS App Store
    ✓ Google Play Store
    ✓ 基础用户获取
    ✓ 用户反馈收集
```

#### 7.1.2 迭代版本计划

```
版本迭代路线图：
├── v1.1 (发布后1个月):
│   ├── Bug修复和性能优化
│   ├── 用户反馈功能改进
│   ├── 新增成就系统
│   └── 社交分享功能
│
├── v1.2 (发布后3个月):
│   ├── 新增高级设备类型
│   ├── 扩展科技树内容
│   ├── 新增统计分析功能
│   └── 改进UI界面
│
├── v1.3 (发布后6个月):
│   ├── 新增军事装备系统
│   ├── 扩展化工生产链
│   ├── 新增挑战模式
│   └── 云存档支持
│
└── v2.0 (发布后1年):
    ├── 多人合作模式
    ├── 工厂设计分享
    ├── 高级自动化系统
    └── 3D可视化界面
```

### 7.2 运营维护计划

#### 7.2.1 日常维护任务

```
维护任务清单：
├── 每日任务:
│   ✓ 监控服务器状态
│   ✓ 检查崩溃报告
│   ✓ 回复用户反馈
│   ✓ 监控关键指标
│
├── 每周任务:
│   ✓ 分析用户数据
│   ✓ 更新内容计划
│   ✓ Bug修复优先级
│   ✓ 竞品分析调研
│
├── 每月任务:
│   ✓ 版本发布计划
│   ✓ 功能需求评估
│   ✓ 技术债务清理
│   ✓ 团队绩效评估
│
└── 每季度任务:
    ✓ 产品路线图调整
    ✓ 技术架构升级
    ✓ 市场策略调整
    ✓ 团队能力建设
```

#### 7.2.2 用户支持体系

```
用户支持计划：
├── 技术支持:
│   ├── 常见问题解答
│   ├── 在线客服系统
│   ├── 用户手册文档
│   └── 视频教程制作
│
├── 社区运营:
│   ├── 官方社区建设
│   ├── 用户活动策划
│   ├── 内容创作激励
│   └── 意见反馈收集
│
├── 问题处理:
│   ├── Bug报告处理流程
│   ├── 功能需求收集
│   ├── 用户投诉处理
│   └── 数据恢复服务
│
└── 持续改进:
    ├── 用户体验优化
    ├── 功能迭代升级
    ├── 性能持续优化
    └── 新技术应用探索
```

---

## 附录

### A. 术语表

- **物品 (Item)**: 游戏中的所有可管理对象
- **设备 (Equipment)**: 用于生产物品的建筑
- **设施 (Facility)**: 设备的同义词，在界面中使用
- **配方 (Recipe)**: 物品的制作方法和材料需求
- **科技包 (Science Pack)**: 用于研发科技的特殊物品
- **净增长 (Net Growth)**: 物品的产量减去消耗量

### B. 数据字典

详细的数据结构定义和字段说明

### C. API 接口文档

内部数据接口和方法定义

### D. 设计资源

UI 设计稿、图标资源、动画规范等

---

**文档信息**

- 版本：v2.7
- 更新日期：2025 年 1 月 27 日
- 文档状态：已更新 - 完善存储设备消耗机制，添加库存检查逻辑
- 主要更新：
  - 物品分类调整为基于 Factorio 的 6 大分类
  - 配方数据结构适配 Factorio 格式
  - 科技系统基于 Factorio 科技包
  - 生产设备基于 Factorio 实际设备类型
  - 数据存储适配 Factorio 数据结构
  - **新增库存更新系统**：累积小数方案处理非整数产量
  - **新增多设备生产处理**：支持多设备同时生产同一物品
  - **新增显示处理方案**：友好显示非整数产量
  - **新增性能优化实现**：批量更新和对象池优化
  - **新增手动生产队列系统**：基于 Factorio Wiki 的完整手动制作机制
  - **新增材料预扣机制**：制作前预扣材料，取消时返还
  - **新增链式制作支持**：自动制作中间产品
  - **新增取消操作机制**：支持单个、5 个、全部取消
  - **新增特殊限制规则**：无法手动制作的物品类型
  - **新增库存满处理**：库存满时暂停制作
  - **新增链式制作优势**：与自动化制作的区别说明
  - **新增用户界面设计**：手动制作队列界面规范
  - **调整配方展示位置**：配方信息区域移至物品介绍下方，优化信息层次结构
  - **优化物品卡片设计**：将右上角数量徽章改为状态徽章，消除与底部库存数量的重复信息
  - **新增状态徽章系统**：基于优先级的状态判断逻辑，提供更直观的物品状态指示
  - **新增库存上限系统**：支持通过箱子/储罐管理物品存储容量，达到上限时自动停止生产
  - **新增存储管理界面**：在物品详情页添加存储管理区域，支持添加/移除存储设备
  - **新增库存满状态**：在状态徽章系统中添加库存满状态，优先级仅次于维护状态
  - **完善存储设备消耗机制**：添加设备时直接消耗箱子/储罐库存，无库存时无法添加
  - **新增库存检查逻辑**：添加设备前检查库存，按钮状态根据库存情况动态调整
- 下一次更新：根据开发进度和用户反馈进行调整
